<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F09%2F06%2FAndroid%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[首先是安装中遇到的问题，参考超详细博客https://blog.csdn.net/hebbely/article/details/78970918关于万能布局ConstraintLayout在3.0以上的版本处理办法，参考博客：https://blog.csdn.net/BSSYNHDJZMH/article/details/79728625显然Android studio自带的约束控件并不能满足ui各种各样的保真所以上述大佬奖励详细ConstraintLayout完全解析]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F09%2F04%2FAndroid%E9%80%86%E5%90%91%2F</url>
    <content type="text"><![CDATA[smali语法学习，参考吾爱破解安卓逆向入门学习https://www.52pojie.cn/thread-408645-1-1.html 在非static方法中，p0代指this，p1为方法的第一个参数。在static方法中，p0为方法的第一个参数。 smali的函数调用smali中的函数和成员变量分为direct和virtual，direct method就是private函数，其余的public和protect函数是virtual method。 invoke-XXX指令： invok-static：调用static函数 invoke-super：调用父类方法指令，一般用于调用onCreate，onDestroy等方法。 invoke-direct：调用privat函数 invoke-virtual：调用public和protect函数 安装adb过程参考博客https://www.cnblogs.com/nebie/p/9145627.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[国密sm4]]></title>
    <url>%2F2019%2F08%2F28%2F%E5%9B%BD%E5%AF%86sm4%2F</url>
    <content type="text"><![CDATA[最近国密SM4加密挺火的，毕竟是中国国家密码局认定的国产密码算法，在逆向加密中出现的比较多。 SM4原理国密SM4官方文档,个人认为官方文档挺好理解的。还有就是一个人截图的浙大diffie教授的课件图片个人觉得里面的图片也很好理解，毕竟国内的资料里面基本没有很好理解的图（悄咪咪搜了一下diffie教授瞬间羡慕好学校的学生们） 加密SM4加密分为三个过程：轮密钥的准备，32次迭代运算，后四位反序得结果 32次迭代运算 图上是32次迭代运算的公式，其中x为输入的值(32bit)，F()是轮函数，rk[i]是轮密钥(32bit)。轮函数的表达式是： 即X1与x2与x3与轮密钥rk[i]异或后的值经过合成置换T函数再与x0异或。合成置换T，由非线性变换τ和先行变换L复合而成： 1.非线性变换τ 非线性变化τ主要操作是把输入的A(8bit)分成四份分别对应到s盒(已知矩阵)中 2.线性变换L 非线性变换的输出即为线性变换的输入，过程为： 反序变换看到这里是不是已经忘记32次迭代运算是什么了…..我们来回顾一下32次迭代运算，以上经过合成置换得到的值要与输入的第一个值x0异或得到的值即为x4的值，经过上面32次轮函数的循环，就能得到新的x0(32bit)到x32的值，最后将最后四个值经过反序变换： 输出即为加密过后的值 轮密钥的准备轮密钥的准备放在后面讲是因为轮密钥也使用了合成置换，但是这个合成置换与前面的轮函数中的合成置换有一点区别。轮密钥生成方法： 输入加密密钥MK(128bit)分成四份MK0(32bit),MK1,MK2.MK3分别与系统参数(已知)FK0,FK1,FK2,FK3异或，下面一个公式我们可以得到两个重要步骤。其中CK[i]为固定参数。 第一步：是类似于32迭代运算的公式得到ki+4 第二步：是我们得到的这个k[i+4]赋值给了rki T′ 是将32次迭代运算中合成置换T的线性变换L替换为L′：系统参数FK的取值：固定参数CK具体值为： 解密本算法的解密变换与加密变换结构相同，不同的仅是轮密钥的使用顺序。解密时，使用轮密钥顺序为（rk31,rk30,…,rk0）. 实现脚本正在修缮中…]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中关村第三届新兴领域专题赛网络与信息安全专项赛线上赛re]]></title>
    <url>%2F2019%2F08%2F23%2F%E4%B8%93%E9%A1%B9%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[贴上题目：https://pan.baidu.com/s/1CPj02KTrmNfNP6JCFRk26Q提取码：el57 flat程序逻辑 check1():判断输入字符串长度是否在50以内 check2():判断输入字符串前几位是否为“flag{” check3():最后一位是否为“}” check4():14,19,23,28 是否为“-” check5():字符串进行字符替换比较 这里是llvm，https://security.tencent.com/index.php/blog/msg/112 脚本：12345678910111213a = 'J2261C63-3I2I-EGE4-IBCC-IE41A5I5F4HB'ans = ''for i in range(0,len(a)): if(ord(a[i])&gt;=65): ans+=chr(ord(a[i])-17) if(a[i]=='-'): ans+=a[i] if(ord(a[i])&gt;=48): if(ord(a[i])&lt;=57): ans+=chr(ord(a[i])+48)print ans src_leakfunc3&lt;func2&gt;这个函数的意思是测试x变为2进制中x含有多少个1，且含1的个数是奇数个 _fun1的意思是开根号，可以根据func1&lt;&gt;处函数可以看出得到result的条件是L=R，而在ifelse&lt;&gt;函数里面当n&lt;midmid时L不变，R减小；当n&gt;=midmid时R不变，L变大。并且保证这几个数和是可能中的最小值，所以反推output平方即是。 最后x6是1到10000有多少素数flag{927369-19324816-44435556-3996001-9865881-1229}]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F13%2F%E5%85%B3%E4%BA%8Ebase64%E5%9C%A8%E9%80%86%E5%90%91%E9%87%8C%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E5%BE%81%2F</url>
    <content type="text"><![CDATA[base64加密是逆向中常见的加密手段，但是如何发现是base64加密呢？ 编码原理 base64加密之后所有的字符都应该在这个表中base64编码是将x个8位字节变成y个6位字节然后再以00填充变成n个新的八位字节，再将二进制转换成十进制，一一替换字符。举个栗子：假设待转化的字符是 “example” 转化成二进制之后得到 01100101 01111000 01100001 01101101 01110000 01101100 01100101 example的长度是7因此为了使得最后得到的字符是4的倍数我们要再添上两个字符 01100101 01111000 01100001 01101101 01110000 01101100 01100101 00000000 00000000 然后我们将其按照6位1字符排好 011001 010111 100001 100001 011011 010111 000001 101100 011001 010000 000000 000000 填充00之后得到 00011001 00010111 00100001 00100001 00011011 00010111 00000001 00101100 00011001 00010000 00000000 00000000 再将这些二进制转换成十进制 25 23 33 33 27 23 1 44 25 16 0 0 对照表用字符替换之后得到 ZXhhbXBsZQAA 再将最后的AA换成==即可 ZXhhbXBsZQ==]]></content>
  </entry>
  <entry>
    <title><![CDATA[锁定文件失败 打不开磁盘“D:\ubuntu\Ubuntu 64 位.vmdk”或它所依赖的某个快照磁盘。 模块“Disk”启动失败。]]></title>
    <url>%2F2019%2F04%2F10%2F%E5%85%B3%E4%BA%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%94%81%E5%AE%9A%E6%96%87%E4%BB%B6%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[锁定文件失败 打不开磁盘“D:\ubuntu\Ubuntu 64 位.vmdk”或它所依赖的某个快照磁盘。 模块“Disk”启动失败。 Ubuntu虚拟机非正常关闭，再次打开有时候会出现“锁定文件失败，打不开磁盘……”的错误提示解决办法：打开虚拟机所在路径删除.vmdk.lck及.vmx.lck两个文件夹中的.lck文件 重启就能使用了]]></content>
      <categories>
        <category>problem</category>
      </categories>
      <tags>
        <tag>program</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 UTCTF]]></title>
    <url>%2F2019%2F04%2F01%2FUTCTF%2F</url>
    <content type="text"><![CDATA[Low Sodium Bagel1234$ steghide extract -sf low-sodium-bagel.jpeg -p ""wrote extracted data to "steganopayload4837.txt".$ cat steganopayload4837.txtutflag&#123;b1u3b3rry_b4g3ls_4r3_th3_b3st&#125; 关于steghide一些使用简单的爆破脚本https://blog.csdn.net/blood_seeker/article/details/81837571关于一些steghide参数介绍https://blog.csdn.net/qq_40657585/article/details/83931078 UTCTF adventure ROM这一题要感谢dotsu师傅的指导，让我这个小白学到了一点东西。 首先是如何打开.gb文件，使用的是Gameboy反汇编追踪工具BGB，BGB 是一款运行于windows 的GameBoy，GameBoy Color 和 Super GameBoy 。模拟器打开的界面如下：开始随便转了转，就DEAD了，然后看了大佬的解释说能输入ABCD，开始找了半天输入，后来才知道要站在每个方框内按A就可以输入了，这样我们可以猜测游戏逻辑，碰到隐藏的东西会死掉，输入不对会LOSER 用IDA分析文件中选择z80处理器，加载进去后还是binary文件，纠结了好久去问了dotsu师傅，最后给出了解决办法：IDA里edit-&gt;select all，然后按C键选force，这样会强制解析整个文件，但是里面的数据和字符串也会被解析为指令，可以对照着hex窗口，按A转为字符串或者按D转为数据。果然大佬就是大佬啊经验丰富，先找到放关键字的地方转字符串 然后找到引用字符串的函数，按x不管用，search-&gt;text也不行，只能手动找了，这里是我看到放关键字符串的地方下面就是sub_73b函数所以猜测引用在sub_33E这个函数里面，看流程图就找到了引用的函数，这样我们就能知道出现DEAD的逻辑了，然后nop掉（nop方法\x00），这样游戏的限制就没有了，同样的方法把所有的DEAD都nop掉，然后选择patch中应用到该文件中 再找到引用LOSER的函数，向上就能看到比较寄存器a，c的值，如果相等就继续循环，如果不相等就跳到LOAER处，那我们只要能弄清楚a和c谁存的是输入的，谁存的是正确值，就能拿到flag了。后面就是用gbg中的debugger来反汇编比较寄存器a，c的值，在比较处下断点，随便输入（F2下断点，F3单步执行，F9继续执行），gbg比较方便能修改寄存器的值修改指令知道结束，并把每一次寄存器c里面的值记录下来，连在一起就是flag。 movIDA加载发现全是MOV指令，可以大概知道使用了Movfuscator进行了混淆处理。 对于复杂一些的Movfuscator程序，可以尝试根据程序中字符串等信息，配合trace工具和下断点来追踪程序流程，并猜测程序逻辑（一般来说逻辑不会特别复杂）。此外，也可以尝试使用Demovfuscator进行反混淆，运气好的话说不定会解得比较好看。（这些都是dutsu师傅写的，小白正学习中） 在gdb中调试，遇到sigill信号会停住，然后发现栈中有一个字符”u”，再试一下就会发现utflag，继续就能得到flag。 关于Movfuscator的学习根据官方介绍Movfuscator是一个单指令C编译器（the single instruction C compiler）]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F18%2Felementary%2F</url>
    <content type="text"><![CDATA[Python的re模块正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019看雪论坛ctf]]></title>
    <url>%2F2019%2F03%2F12%2F%E7%9C%8B%E9%9B%AA2019%2F</url>
    <content type="text"><![CDATA[流浪者提取码s7pn链接https://pan.baidu.com/s/1xFLUjOETe9ICFdJqVTcYlw 首先题目入口函数是sub_401890，我是通过在OD里面查找字符串，找到“请输入pass”的地址，然后在IDA中找到该函数并反汇编得到了整个函数 进入sub_4017F0函数通过条件得到pass 脚本如下：12345678910111213141516key = 'KanXueCTF2019JustForhappy'str1 = 'abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ'a1 = ''for i in range(0,len(key)): for j in range(0,62): if(str1[j] == key[i]): if(j &gt;= 0): if(j &lt;= 9): a1 += chr(j + 48) if(j &gt;= 10): if(j &lt;= 35): a1 += chr(j + 87) if(j &gt;= 36): if(j &lt;= 61): a1 += chr(j + 29) print(a1) flag是j0rXI4bTeustBiIGHeCF70DDM]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TAMU CTF Re]]></title>
    <url>%2F2019%2F03%2F05%2FTAMU%20CTF%20Re%2F</url>
    <content type="text"><![CDATA[TAMU CTF 逆向有简单也有复杂的，前天刚结束，今天把这个总结一下。附上题目，提取码rb8rhttps://pan.baidu.com/s/1A5G-pRd3oYkzVYVJDVIxvQ Cheesy文件放到Ubuntu中运行一遍，发现采用了base64编码，把给出的加密代码解密，并没有发现flag，并且解密之后告诉你你已经错过了flag，所以考虑，是否还有未解密的隐藏代码，放到ida中发现了1Z2lnZW17M2E1eV9SM3YzcjUxTjYhfQ== 这一串密码未输出，经过解密就是flag1gigem&#123;3a5y_R3v3r51N6!&#125; Snakes over cheese给的是一个.pyc文件，用uncompyle反编译一下得到.py文件，使用命令1uncompyle6 reversing2.pyc &gt; reversing2.py 的得到如下的py文件，运行一下发现需要输入正确的密码才能给你flag不用那么麻烦的把密码给逆向出来，直接修改一下py文件直接得出flag运行结果如下： 042这是一道真正的反汇编，给的文件不能编译所以要纯看汇编代码，但是这个汇编代码还是很简单的，前面第一个function是一个迷惑代码，实质上没用，主要看main函数，关键代码在如下地方在第二printf函数后面放入的是栈中[rbp-16]的地址，即从[rbp-16]向下取值回到上面就能看到存入栈中的值，即可获得flag1gigem&#123;A553Mb1Y&#125; keygenme把enc()这个函数逆向就完了，但是有一个需要注意的地方，这里输入的a1在运行过程中strlen()函数包含了输入时的回车符’\n’所以根据得到v5知道a1的长度应该是17，但是包含了最后的回车符，所以a1只有16个，脚本如下提交就能得到flag，比赛的时候一直没有想到这个问题，知道是多了个’Enter’但是实在没想到是这样，比赛结束后用C语言正着证明了一遍 #NoCCBytes#放到ida里面re了一下发现答案在globPass中，显然DATA中的字符串肯定不是，但是我们可以动态调试啊，但是文件开了保护机制，所以下断点的时候要绕开这些保护机制，所以直接一点直接把断点下在字符串比较的地方。然后就看到内存中的golbpass满眼答案…提交就能得到flag]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Seasides CTF breakthis]]></title>
    <url>%2F2019%2F03%2F01%2FSeasides%20CTF%202019%20re%2F</url>
    <content type="text"><![CDATA[这个比赛当时比的时候没找到时间，比的时候只剩最后两个小时，所以只做了两道re，nondbg这题应该比较明显按照代码的顺序把字符串正确输入就会得到flag，breakthis也很简单，验证你输入的flag是否正确，你输入的flag经过base64，rot13，uuencode加密后要跟flag_encode一样，而flag_encode已知，只要将他反过来解密就行，写这篇的意义主要是学习使用python解密 附上题目，提取码fdt4https://pan.baidu.com/s/1tyLuV8hRLemkSlsq2Wk-QQ 编码转换时，通常要以Unicode为中间编码，即都需要将字符串先解码（decode）成Unicode再从Unicode编码成（encode）成另一种编码 如果一个字符串已经是unicode了，再进行解码则将出错,因此通常要对其编码方式是否为unicode进行判断isinstance(s, unicode) #用来判断是否为unicode uuencode是将二进制文件编码成为ascii，uudecode是用于uuencode编码的文件还原为原来的二进制文件。关于uuencode输出数据，都是以begin开头，以end结尾。begin后面644是unix档案调用的权限代码 关于codecs的使用手册介绍https://docs.python.org/3/library/codecs.html 下面是解密代码，需要注意uuencode的格式 取得flag 附上一些可以直接用python编码和解码的一些密码，这样能大大的节约时间，但是注意python2.7和python3的区别，byte string和Unicode string编码要求在python3中的要求就更严格，在python3中区分了二进制和字符串，所以这个脚本在python3中会出现问题]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于逆向学习的一些知识]]></title>
    <url>%2F2018%2F11%2F23%2F%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[API：API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。API函数包含在Windows系统目录下的动态连接库文件中。。API说来说去，就是一种函数，他们包含在一个附加名为DLL的动态连接库文件中。Windows API是一套用来控制Windows的各个部件的外观和行为的预先定义的Windows函数。用户的每个动作都会引发一个或几个函数的运行以告诉Windows发生了什么。这在某种程度上很像Windows的天然代码。而其他的语言只是提供一种能自动而且更容易的访问API的方法。当你点击窗体上的一个按钮时，Windows会发送一个消息给窗体，VB获取这个调用并经过分析后生成一个特定事件。更易理解来说：Windows系统除了协调应用程序的执行、内存的分配、系统资源的管理外，同时他也是一个很大的服务中心。调用这个服务中心的各种服务(每一种服务就是一个函数)可以帮助应用程序达到开启视窗、描绘图形和使用周边设备等目的，由于这些函数服务的对象是应用程序，所以称之为Application Programming Interface，简称API 函数。WIN32 API也就是MicrosoftWindows 32位平台的应用程序编程接口。凡是在 Windows工作环境底下执行的应用程序，都可以调用Windows API。其实就是用户指令先由编程语言编程成电脑能读懂的语言，这个语言能自动的更快的访问API，这样应用程序通过API与Windows某些部件连接起来，让Windows内部运作起来完成用户指令，并返回给用户界面。API是应用程序接口。你可以在其他的程序中，通过一定的规范通过API发送信息给另一个程序，并接收返回的结果。看了很多，一个很有意思的回答是，双方交流的暗号 vc6入口代码特征：都是push ebp；mov ebp，esp类似的；入口调用API也是相同的vc6的四个区段：.text代码段.rdata导入表（只读数据段）.data数据段.rsrc资源段vs2008和vs2013相较于vc6：入口代码只有两行，vs2018是一个call后面接一个jmp，第一个call里面进去后也是push ebp啥啥的，调用的API也相同VB启动代码：jmp ThunRTMain();push RT_MainStruct结构体函数地址；call (jum ThunRTMain()地址);前面压入栈的的值作为ThunRTMain()函数参数 易语言（非独立编译）：编译时很明显的运行库文件，入口特征和模块特征都有krnln.fnr，易语言支持库有.fnr格式,.fne格式和.npk格式 OD被压缩后分析：ctrl+A加aspack壳的特征：入口特征pushad，一个call和jmp，并且会增加两个区段 加UPX壳后特征： https://www.cnblogs.com/Fightingbirds/p/3172907.html]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018i春秋骇极杯what]]></title>
    <url>%2F2018%2F11%2F07%2F2018i%E6%98%A5%E7%A7%8B%E9%AA%87%E6%9E%81%E6%9D%AFwhat%2F</url>
    <content type="text"><![CDATA[骇极杯第二个逆向，也不难，也是两个函数，首先是爆破MD5，然后进行动态解密check函数 这是结束几天之后，我再来写的wp，我开始觉得很简单的，后来看了详细的过程之后我觉得我还是有很多却缺陷的，下面开始一步一步分析 首先拖进ida，主要分两部分来看： 要先得到luck string才能获得check函数的内容，所以先对MD5进行爆破 12345678910111213141516import hashlibfor a1 in range(97,123): for a2 in range(97,123): for a3 in range(97,123): for a4 in range(97,123): for a5 in range(97,123): for a6 in range(97,123): asc=hashlib.md5((char(a1)+char(a2)+char(a3)+char(a4)+char(a5)+char(a6)).encode('ascii')).hexdigest() v5=0 v4=0 for i in range(32): if(asc[i]=='0'): v5+=1 v4+=i if(10*v5+v4==403): print(chr(a1)+chr(a2)+chr(a3)+chr(a4)+chr(a5)+chr(a6)) 脚本我放在虚拟机里面跑了半个小时，最后得出了luck string = ozulmt。 再弄出v4和v5]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018网鼎杯之beijing]]></title>
    <url>%2F2018%2F11%2F06%2F2018%E7%BD%91%E9%BC%8E%E6%9D%AF%E4%B9%8Bbeijing%2F</url>
    <content type="text"><![CDATA[题目不难，但是我不会写脚本，学习的大佬的先贴上地址，稍后来写https://blog.csdn.net/re_psyche/article/details/81947537]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于git bash无法上传更新博客]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%85%B3%E4%BA%8Egit%20bash%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[之前blog不知道出了什么问题一直显示上传成功，却依旧不能更新，后来才发现问题，如图： 配置缺少GitHub邮箱和用户名…..好的吧，加上加上 上传文件到远程仓库]]></content>
      <categories>
        <category>problem</category>
      </categories>
      <tags>
        <tag>problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018i春秋骇极杯cpp]]></title>
    <url>%2F2018%2F11%2F04%2Fi%E6%98%A5%E7%A7%8B%E9%AA%87%E6%9E%81%E6%9D%AFreverse%2F</url>
    <content type="text"><![CDATA[逆向呢真的是一边学一边写题过来的，我比较喜欢这样贴上题目https://pan.baidu.com/s/1KDQs81aqUYl7T7E9mZO-SQ C plus plus拖到IDA里面看一看，发现main函数里面有两个特别重要的加密函数，点击进去看看因为正在学c++所以呢，就去把basic_ string这个类去看了一下（真的是萌新要学习的东西很多呢） 贴上学习的地址，个人更偏向英文版，英文版：http://www.cplusplus.com/reference/string/basic_string/basic_string/中文版：https://blog.csdn.net/hl156/article/details/80610597 basic_ string(char &amp;s1,char &amp;s2)是把s2字符串赋值给s2；若是basic_string(char &amp;s1,int n)是打印出s1前n个字符，以字符串的形式；basic _string(char &amp;s1,int n,int m)若n&lt;m是打印出s[n]到s[m]之间的字符串,若n&gt;m是打印出s[n]后面m个字符（都包括s[n]）；basic _string(int n,’a’)是打印n个a出来，等等….~basic_string()则是删除这个字符串operate就是取字符串第i位的字符出来c-str()返回指向数组的指针，该数组包含表示basic _string对象当前值的以空字符结尾的字符序列（即C字符串）。即此数组包含构成basic _string对象的值的相同字符序列以及末尾的附加终止空字符（charT（））。下面代码助于理解，其中strtok这个函数下面是他的固定格 好了，好了废话太多了 以下是第一个加密函数经过调试无论如何都会通过第一加密函数的，第一个是简单的异或与位移所以算法就是左移数组六位|右移数组两位再按位异或 第二个加密函数就比较复杂我调试了之后大概意思是跟前面一个异或 下面是我的脚本，参考了大佬（Mr.Riscker)的代码的，觉得很简洁 当当当，flag如下 偶然在吾爱论坛上找到了一个讲解及其细致的wp，很适合我这种新人看啊贴上地址https://www.52pojie.cn/thread-819393-1-1.html 里面讲到了之前我没有注意到的几点，我重新加上： a&lt;&lt;2这个从哪里来：在ida上面第一个函数中有v2 = 4 * *(char *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](a1, i);这个并不是讲a1*4而是在进行”a&lt;&lt;2”的操作 代码中的&amp;0xff：第一个加密函数进行了a[i]=(a[i]&lt;&lt;2|a[i]&gt;&gt;6)^i这样的一个操作，但是异或i这一步跑不出来，所以还要加上&amp;0xff才行，byte类型的数字要&amp;0xff再赋值给int类型，是想保持二进制补码的一致性（数据在计算机中存储是以二进制的方式，正数存储的二进制原码,负数存储的是二进制的补码，补码是负数的绝对值反码加1）]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学PWN---栈溢出]]></title>
    <url>%2F2018%2F10%2F12%2F%E5%88%9D%E5%AD%A6pwn%E4%B9%8B%E6%A0%88%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[经过百转千回弯弯绕绕我这个可爱的程序媛最终还是屈服在PWN的淫威下，接下来的内容是我PWN入门的一些知识，如果有什么知识性的错误，请大方指出来，给你奖励小发发❀ 首先，在学PWN之前我学了C语言和汇编语言，还了解一点python和Linux系统的基本操作，并且也有一点点逆向工程 的基础，学PWN主要是看YouTube上面一个声音巨好听的美国不露面小哥哥的视频，这个小哥哥三年前也是一边自学PWN一边录视频，讲的很基础好懂又幽默有趣，最近看到小哥哥去了拉斯维加斯参加defcon 和blackhat，而且那个小哥哥竟然还是个学生，无数次感觉输在了人生的起跑线上呢，我也才上大学，他在上大学就知道那么多知识，而我还只是个萌新呢，一起加油~~（暗戳戳的说一句，感觉那个小哥哥长得好高啊，对我来说高=帅） 废话不多说，贴上视频地址http://liveoverflow.com/ stack0~4这几个原理基本是差不多的，通过栈溢出将某值改变或者覆盖返回地址 0~4的答案和需要注意的地方stack0主要讲的是覆盖掉modified的值让它不等于0即可，那我们首先找到buff的地址和modified的地址0x080483fd &lt;main+9&gt;: movl $0x0,0x5c(%esp)为modified的地址 () 0x08048405 &lt;main+17&gt;: lea 0x1c(%esp),%eax 0x08048409 &lt;main+21&gt;: mov %eax,(%esp) ()是buff的地址两个地址0x5c和0x1c相差0x40个字节再加上0X1个需要覆盖的字节 代码如下： $ python -c ‘print “A”*0x40+”\x01\x00\x00\x00”‘ | ./stack you have changed the ‘modified’ variable stack1让modified的地址等于0x61626364,思路同上题，不过要注意的是x86系列的电脑都是采用小端序的方式储存数据。 小端序和大端序： 小端序：字数据的低字节存储在低地址中。大端序：字数据的高字节存储在低地址中。 代码如下： ./stack1 $python -c ‘print “A”*0x40+”dcba”‘ you have correctly got the variable to the right value stack2此处需要设置环境变量GREENIE 代码如下： $ GREENIE=`python -c ‘print “A”*0x40+”\x0a\x0d\x0a\x0d”‘ $ export GREENIE $ ./stack2 you have correctly modified the variable stack3此处我们需要跳到win函数处，首先获得win函数的地址: (gdb)print win得到$1 = {void (void)} 0x8048424 &lt;win&gt;获得地址之后直接覆盖fp 代码如下： $python -c ‘print “A”*0x40+”\x24\x84\x04\08”‘ | ./stack3 calling function pointer, jumping to 0x08048424 code flow successfully changed stack4覆盖返回地址让他跳到win函数就行了，注意这里要多覆盖0x1字节，偏移为0x4c 代码如下： $ python -c ‘print “A”*0x4C+”\xf4\x83\x04\x08”‘ | ./stack4 code flow successfully changed Segmentation fault stack5 首先介绍shellcode：Shellcode实际是一段代码（也可以是填充数据），是用来发送到服务器利用特定漏洞的代码，一般可以获取权限。另外，Shellcode一般是作为数据发送给受攻击服务器的 再介绍int 3（CC）：当被调试进程执行INT3指令导致一个异常时，调试器就会捕捉这个异常从而停在断点处，然后将断点处的指令恢复成原来的指令用INT3断点的好处是可以设置无数个断点，缺点是改变了原程序指令，容易被软件检测到。例如为了防范API被下断，一些软件会检测API的首地址是否为CCh，以此来判断是否被下了断点但是如果将断点下在函数的内部或者末尾，例如可以将断点下在函数入口的下一行，就可以躲过检测了 再来说说整个做题的想法，代码极其简单，但是我思考了很久为什么要这么做，暂时无果，按照视频所讲通过在缓存区放入shellcode通过管道传输给stack5，然后得到root权限 Shellcode放在返回地址后面，前面跟上NOP Slot；这可以消除缓冲区位置的不确定性。 注意:非GDB运行和GDB运行，缓冲区的地址会有变化注意：这里使用的”()”会生成一个子shell； 子shell中执行两条命令。 第一条命令将payload输出到标准输出，通过管道传输给stack5； 第二个命令cat从标准输入中读取数据输出到标准输出，也会通过管道传输给stack5； builtin_ return_ address(0)的含义是，得到当前函数返回地址，即此函数被别的函数调用，然后此函数执行完毕后，返回，所谓返回地址就是那时候的地址。_builtin_return_address(1)的含义是，得到当前函数的调用者的返回地址。注意是调用者的返回地址，而不是函数起始地址。利用builtin_return_address来获得函数运行栈的方法。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018看雪论坛ctf第一题]]></title>
    <url>%2F2018%2F07%2F28%2F2018%E7%9C%8B%E9%9B%AA%E8%AE%BA%E5%9D%9B%E7%AC%AC%E4%B8%80%E9%81%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这是long long ago 以前的CTF简单的解题思路，刚开始接触的逆向工程，所以从简单的开始吧！（ps：下一篇应该是iscc逆向Reverse题解，这是我做出来的第一个逆向工程题） ##2018看雪CTF之XCTF## 此处贴上题目：https://pan.baidu.com/s/15AJ5rXllWDwMhsX2dUKHyQ 首先打开.exe文件可以看到如下： 要求输入正确的序列号…… 正常情况下我们拖到OD里面看一下，找到关键句： 进入之后，随便输入一个值先调试一下： 此时我们需要找到关键跳转，在关键跳转处下断点： 下完断点后，直接运行到断点处，发现寄存器这边多了一个ASCII码值，此值就是我们要找到的值： 这个时候我们把这个值输进去，明显不对，想到可能是16进制转字符串，得到答案： 没错！！！答案就是如此简单，hhhh….]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
