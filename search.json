[{"url":"/2020/05/10/梆梆加固原理及脱壳/"},{"url":"/2020/04/20/New Document/","content":"load_const 变量赋值\nload_fast 加载局部变量\nstore_fast 保存值到变量\nload——global 加载全局变量"},{"title":"android studio 3.5编译一个.so","url":"/2020/04/06/android studio 3.5编译一个so/","content":"\n# 简单介绍JNI和NDK #\nJNI：Java Native Interface,java本地接口，可以使Java与本地其他语言进行交互，如C语言，C++。\nNDK：Native Development Kit是Android的一个开发工具包，快速开C与C++的动态库，并自动将so文件和应用一起打包成APK\n# 简单快速方法 #\n\n先在setting下载好ndk，cmake，lldb，然后新建项目\n\n![](https://i.imgur.com/vuTGObh.png)\n\n选择native c++然后next，输入项目名称，一路next到finish。\n\n![](https://i.imgur.com/AOPoQgC.png)\n打开main文件夹下的cpp文件，可以看到已经写好的CMakeLists.txt和native-lib.cpp，native-lib.cpp文件，它是提供对外接口的，之后我们调用时就是通过一个java类调用这个c++文件中的接口的。\n\n打开main文件夹下的build.gradle,填写一些配置\n![](https://i.imgur.com/GVZtIUH.png)\n修改成：\n![](https://i.imgur.com/WVGT5HY.png)\nbuild一下就生成了.so文件，在app——>build——>intermediates——>cmake下生成对应的.so库\n\n使用此种方法.so文件声明调用都在MainActivity中，而且对外接口只有一个native-lib.cpp,不能使用多个.cpp文件实现功能。\n解决办法：第一种：参考完整版写一个Java文件用javah生成.h文件，完成c代码复制到之前的native-lib.cpp中，然后rebuild；第二种将得到的接口文件（.h文件）在cpp文件夹下新建一个.cpp文件将接口文件的代码复制进去，并在CMakeLists.txt中添加新.cpp文件的源文件地址，rebuild即可。\n\n# 完整版 #\n个人觉得这个版本复杂很多但是我们可以更完整的了解建立so库的全部过程，对于后面逆向的学习有更好的理解\n\n新建一个空项目，在Project Structure里面配置好NDK，不知道为什么在gradle3.5不能下载应用ndk之后自动配置，每一次要手动配置。\n![](https://i.imgur.com/NvsVJfd.png)\n![](https://i.imgur.com/woB6DhH.png)\n检查是否配置好在gradle这个文件夹下查看local.properties文件里面是否函数有ndk的地址。![](https://i.imgur.com/6Uuqts2.png)\n\n新建一个Testjni.java\n```JAVA\npublic class MyJni {\n\n    static {\n        System.loadLibrary(\"testjni\");\n    }\n\n    public native static String getString();\n}\n\n```\n点击build-->make project,生成.class文件\n\n找到classes文件夹，一般在E:\\Android\\TestJNI\\app\\build\\intermediates\\javac\\debug下，使用javah来生成.h文件，命令为``` javah -jni com_example_testjni_testjni ```,生成com_example_testjni_testjni.h\n\n在src/main/下创建jni目录将上述.h文件复制进去，并创建.c文件，并把下面代码复制进去\n```JAVA\n#include <jni.h>\n#include \"com_example_testjni_testjni.h\"\n#include <stdio.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nJNIEXPORT jstring JNICALL com_example_testjni_testjni_getString\n  (JNIEnv *env, jclass jz){\n\n  return (*env)->NewStringUTF(env,\"this is the first time for me to use jni\");\n\n  }\n#ifdef __cplusplus\n}\n#endif\n```\n再创建Android.mk和Application.mk文件（个人觉得这种太麻烦了，Cmake简单明了）\nAndroid.mk是一个向Android NDK构建系统描述NDK项目的GNU makefile片段。我的理解是链接文件，告诉ndk操作的一些信息\n**Android.mk**\n```\n#定义模块当前路径(必须定义在文件开头，只需定义一次)\nLOCAL_ PATH := $(call my-dir)\n#清空当前环境变量 (LOCAL_PATH除外)\ninclude $(CLEAR_VARS )\n#当前模块名(这里会生成libhello-jni.so),模块名唯一,且不能包含空格\nLOCAL_MODULE := testjni\n#当前模块包含的源代码文件\nLOCAL_ SRC_ FILES := test.c\n#表示当前模块将被编译成一个共享库\ninclude $(BUILD_ SHARED_LIBRARY)\n```\n**Application.mk**\n```\nAPP_ABI := armeabi armeabi-v7a x86 // 生成so文件的平台 ，设置为all, 代表所有平台\n```\n切换到main目录下 执行ndk-build 生成so文件\n\n将我们生成的so文件复制到 app下的libs文件夹下，并配置build.gradle 文件\n\n在MainActivity中调用\n\n别问我图在哪儿，上传不了。","tags":["Android Reverse"],"categories":["study"]},{"title":"AUCTF一道逆向题","url":"/2020/04/06/AUCTF2020一道题/","content":"\n跟学弟一起做的一道逆向题，先给出了一个32位PE，破解之后发现flag不在那儿，至于破解过程我就不赘述了，感觉应该是个位移解密。\n![](https://i.imgur.com/fZUiBPu.png)\n这个时候我们发现他给出了一个新的IP，我们在网页上查看这个地址，发现网站里面有一个php文件，这就说明我们需要跟他的服务器进行交互。我尝试了一下发现怎么都不能交互成功，靠我仅有的web知识挣扎了一下，就放弃了。\n\n看完wp之后发现，给的PE文件里面竟然还有一个PE文件，用binwalk查看了一下发现0x24B0这里往后是一个新的PE，用winhex把它分离出来，得到新的PE文件，运行之后发现需要输入IP:PORT，正好之前给了新的地址和端口号，成功进入。\n![](https://i.imgur.com/KpOJo0u.png)\n当然这肯定没解决完，他肯定不会连上了就告诉你flag，所以后面我们分析这个PE文件，很显然都是GO语言，这里就要去学习GO语言了，第二种方法运行exe的时候用Wireshark抓包，web方向的知识我也不赘述了。\n贴上question.php代码\n```php\n\n<?php\n$my_headers = apache_request_headers();\n$hello = $_SERVER['HTTP_HELLO'];\n$hand = $_SERVER['HTTP_COOKIE'];\n\nif ($hello ==  \"hello can you hear me?\"){\n\theader(\"COOKIE:you_found_me\");\n\techo \"Ahh. I see you've found me... here comes the flag :)\\n\";\n}\nif ($hand == \"you_found_me\"){\n\t\techo \"auctf{r3s0urc3_h4cK1Ng_1S_n3at0_1021}\\n\";\n\t}\n?>\n\n```\n之所以写这个是因为最近看了嘶吼公众号推的一篇文章，APT组织利用IE和Firefox漏洞攻击，感觉在这个攻击手段跟这题解决方法在某些方面有点类似，只不过这个要简单很多。","tags":["Android Reverse"],"categories":["study"]},{"title":"流加密rc4","url":"/2019/11/05/流加密rc4/","content":"在密码学中，RC4（来自Rivest Cipher 4的缩写）是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。该算法是一个可变密钥长度、面向字节操作的流密码。该算法以随机置换作为基础，其密码周期很可能大于10100，且该算法的运行速度很快。（来自百度百科）\n\nRC4密钥生成步骤主要分成两部分初始化算法（KSA）和伪随机子密码生成算法（PRGA)两大部分。先放上图助于理解：\n![](https://i.imgur.com/mtt6esP.jpg)\n# 初始化算法： #\n\n## 初始化状态向量S（256个字节，用来作为密钥流生成的种子1）： ##\n给向量S256字节一一赋值，从0，1，2，3......255。\n```c\nint s[256] = {0};\nfor(int i = 0; i < 256; i++)\n{\n\ts[i] = i;\n}\n```\n\n## 初始密钥（256字节，不满循环填满）： ##\n这个值是用户自定义的，长度任意，不满256字节循环填满，非明文，是已知的\n```\nchar *key = \"aaaaaa\";\nint len = strlen(key);\nunsigned char k[256] = {0};\nfor(int i = 0;i < 256; i++)\n{\n\tk[i] = key[i/len];\n}\n```\n\n## 对状态向量S进行置换操作（打乱S_box）： ##\n规则如下：\n```c\nint j = 0;\nchar temp;\nfor(int i = 0;i < 256; i++)\n{\n\tj = (j + s[i] + k[i])%256;\n\ttemp = s[i];\n\ts[i] = s[j];\n\ts[j] = temp;\n}\n```\n# 伪随机子密码生成算法 #\n加密：明文字节数为：datalength\n```c\nint i = 0;\nint j = 0;\nwhile(datalength--)\n{\n\ti = (i + 1)%256;\n\tj = (j + s[i])%256;\n\tswap(s[i] , s[j]);\n\tt = (s[i] + s[j])%256;\n\tdata[i] = data[i] ^ s[t];\n}\n```\n解密：明文异或一次得到密文，再异或一次得到原来的明文\n\n参考百度百科完整代码：\n```c\n//程序开始\n#include<stdio.h>\n#include<string.h>\ntypedef unsigned longULONG;\n \n/*初始化函数*/\nvoid rc4_init(unsigned char*s, unsigned char*key, unsigned long Len)\n{\n    int i = 0, j = 0;\n    char k[256] = { 0 };\n    unsigned char tmp = 0;\n    for (i = 0; i<256; i++)\n    {\n        s[i] = i;\n        k[i] = key[i%Len];\n    }\n    for (i = 0; i<256; i++)\n    {\n        j = (j + s[i] + k[i]) % 256;\n        tmp = s[i];\n        s[i] = s[j];//交换s[i]和s[j]\n        s[j] = tmp;\n    }\n}\n \n/*加解密*/\nvoid rc4_crypt(unsigned char*s, unsigned char*Data, unsigned long Len)\n{\n    int i = 0, j = 0, t = 0;\n    unsigned long k = 0;\n    unsigned char tmp;\n    for (k = 0; k<Len; k++)\n    {\n        i = (i + 1) % 256;\n        j = (j + s[i]) % 256;\n        tmp = s[i];\n        s[i] = s[j];//交换s[x]和s[y]\n        s[j] = tmp;\n        t = (s[i] + s[j]) % 256;\n        Data[k] ^= s[t];\n    }\n}\n \nint main()\n{\n    unsigned char s[256] = { 0 }, s2[256] = { 0 };//S-box\n    char key[256] = { \"justfortest\" };\n    char pData[512] = {0};\n    unsigned long len = 0;\n    int i;\n\n\tscanf(\"%s\",&pData); \n\tlen = strlen(pData); \n    printf(\"pData=%s\\n\", pData);\n    printf(\"key=%s,length=%d\\n\\n\", key, strlen(key));\n    rc4_init(s, (unsigned char*)key, strlen(key));//已经完成了初始化\n    printf(\"完成对S[i]的初始化，如下：\\n\\n\");\n    for (i = 0; i<256; i++)\n    {\n        printf(\"%02X\", s[i]);\n        if (i && (i + 1) % 16 == 0)putchar('\\n');\n    }\n    printf(\"\\n\\n\");\n    for (i = 0; i<256; i++)//用s2[i]暂时保留经过初始化的s[i]，很重要的！！！\n    {\n        s2[i] = s[i];\n    }\n    printf(\"已经初始化，现在加密:\\n\\n\");\n    rc4_crypt(s, (unsigned char*)pData, len);//加密\n    printf(\"pData=%s\\n\\n\", pData);\n    printf(\"已经加密，现在解密:\\n\\n\");\n    //rc4_init(s,(unsignedchar*)key,strlen(key));//初始化密钥\n    rc4_crypt(s2, (unsigned char*)pData, len);//解密\n    printf(\"pData=%s\\n\\n\", pData);\n    return 0;\n}\n \n//程序完\n```\n参考文章：[https://www.cnblogs.com/gambler/p/9075415.html](https://www.cnblogs.com/gambler/p/9075415.html)","tags":["cryptography"],"categories":["study"]},{"title":"Android 逆向学习中遇到的问题","url":"/2019/09/06/Android开发中遇到的问题/","content":"# Android studio安装过程中的问题 #\n首先是安装中遇到的问题，参考超详细博客[https://blog.csdn.net/hebbely/article/details/78970918](https://blog.csdn.net/hebbely/article/details/78970918)\n\n# 关于万能布局 #\n关于万能布局ConstraintLayout在3.0以上的版本处理办法，参考博客：[https://blog.csdn.net/BSSYNHDJZMH/article/details/79728625](https://blog.csdn.net/BSSYNHDJZMH/article/details/79728625)\n显然Android studio自带的约束控件并不能满足ui各种各样的保真所以上述大佬写了详细ConstraintLayout完全解析\n\n# smali文件动态调试出现的问题 #\n关于动态调试smali文件出现的一些问题\n\n首先把smali文件夹导出后一定要放在一个文件夹里面并且将smali文件改名为src\n\n检查xml文件是不是有允许调试的语句\n\n关于android device monitor在Android SDK安装文件夹tools文件夹下monitor.bat双击即可打开\n\n输入命令adb shell -D -n hfdcxy.com.myapplication/hfdcxy.com.myapplication.MainActivity只能使用这个命令，其他命令搜索不到\n\nandroid device monitor 查看online端口，查看完就关闭，否则后面会转发端口失败\n\n打开命令行窗口 输入命令 adb forward tcp:8700 jdwp:19509    转发8700 端口 (这里 jdwp是自己Android Device Monitor中要调试app的Online值 )\n\n后面重新打开Android studio调试文件不能下断点，后来发现重新调试文件的时候没有安装ideasmali，要重新在安装上才能下断点\n\n# 关于使用Android studio出现的一些问题 #\n在某一天我打开Android studio我发现他坏了。。。\n1.AndroidStudio中Could not find any version that matches com.android.support:appcompat-v7:29.+.\n解决方案：改为 --> implementation 'com.android.support:appcompat-v7:+' 即可\n参考https://blog.csdn.net/hai1124948893/article/details/85247737\n2.修改gradle路径，参考网上教程","tags":["Android Reverse"],"categories":["study"]},{"title":"Android 逆向学习","url":"/2019/09/04/Android逆向/","content":"# smali基础 #\nsmali语法学习，参考吾爱破解安卓逆向入门学习[https://www.52pojie.cn/thread-408645-1-1.html](https://www.52pojie.cn/thread-408645-1-1.html)\n![](https://i.imgur.com/vSN2ZAy.jpg)\n![](https://i.imgur.com/6I1GHER.jpg)\n![](https://i.imgur.com/tBwzBWO.jpg)\n![](https://i.imgur.com/eDRiUON.jpg)\n![](https://i.imgur.com/oEOhZDa.jpg)\n\n## 记录一些易混淆的点 ##\n### 寄存器p0 ###\n在**非**static方法中，**p0**代指**this**，**p1**为方法的第一个**参数**。\n在static方法中，**p0**为方法的第一个**参数**。\n\n### .local与.locals ###\n```smali\n\t.local v1, \"future\":Lcom/android/volley/toolbox/RequestFuture;, \"Lcom/android/volley/toolbox/RequestFuture<Ljava/lang/Void;>;\"\n```\n这里的.local表示的是\n```\n\tRequestFuture<Void> future； \n\tfuture = v1；\n```\n.locals 数字 定义所学内部变量数，即v寄存器的数\n\n# smali的函数调用 #\nsmali中的函数和成员变量分为direct和virtual，direct method就是private函数，其余的public和protect函数是virtual method。\n\ninvoke-XXX指令：\n1. invok-static：调用static函数\n2. invoke-super：调用父类方法指令，一般用于调用onCreate，onDestroy等方法。\n3. invoke-direct：调用privat函数\n4. invoke-virtual：调用public和protect函数\n# 破解的程序和游戏 #\n安装adb过程参考博客[https://www.cnblogs.com/nebie/p/9145627.html](https://www.cnblogs.com/nebie/p/9145627.html)\n破解过的游戏：\n# 动态调试 #\n具体会在另一个博客详细讲解，详细学习Java层和so层动态调试后写的博客\n\n","tags":["Android Reverse"],"categories":["study"]},{"title":"国密sm4","url":"/2019/08/28/国密sm4/","content":"\n最近国密SM4加密挺火的，毕竟是中国国家密码局认定的国产密码算法，在逆向加密中出现的比较多。\n\n## SM4原理 ##\n\n国密SM4[官方文档](http://dacas.cn/sharedimages/ARTICLES/SMAlgorithms/SM4.pdf),个人认为官方文档挺好理解的。还有就是一个人截图的浙大diffie教授的[课件图片](https://blog.csdn.net/zhangpeterx/article/details/83654504)个人觉得里面的图片也很好理解，毕竟国内的资料里面基本没有很好理解的图（悄咪咪搜了一下diffie教授瞬间羡慕好学校的学生们）\n\n## 加密 ##\n\n**SM4加密分为三个过程：轮密钥的准备，32次迭代运算，后四位反序得结果**\n\n### 32次迭代运算 ###\n\n![](https://i.imgur.com/FPx1NtS.png)\n\n图上是32次迭代运算的公式，其中x为输入的值(32bit)，F()是轮函数，rk[i]是轮密钥(32bit)。**轮函数**的表达式是：\n\n![](https://i.imgur.com/plsjIQr.png)\n\n即X1与x2与x3与轮密钥rk[i]异或后的值经过**合成置换T函数**再与x0异或。\n合成置换T，由**非线性变换τ**和**先行变换L**复合而成：\n![](https://i.imgur.com/9cssMkC.png)\n\n1.非线性变换τ\n\n非线性变化τ主要操作是把输入的A(8bit)分成四份分别对应到s盒(已知矩阵)中\n\n![](https://i.imgur.com/sX7qAge.png)\n\n2.线性变换L\n\n非线性变换的输出即为线性变换的输入，过程为：\n![](https://i.imgur.com/mKuplwC.png)\n\n### 反序变换 ###\n\n看到这里是不是已经忘记32次迭代运算是什么了.....我们来回顾一下32次迭代运算，以上经过合成置换得到的值要与输入的第一个值x0异或得到的值即为x4的值，经过上面32次轮函数的循环，就能得到新的x0(32bit)到x32的值，最后将最后四个值经过**反序变换**：\n\n![](https://i.imgur.com/1drebMg.png)\n\n输出即为加密过后的值\n\n### 轮密钥的准备 ###\n\n轮密钥的准备放在后面讲是因为轮密钥也使用了合成置换，但是这个合成置换与前面的轮函数中的合成置换有一点区别。\n轮密钥生成方法：\n\n![](https://i.imgur.com/mCSY2SF.png)\n\n输入加密密钥MK(128bit)分成四份MK0(32bit),MK1,MK2.MK3分别与系统参数(已知)FK0,FK1,FK2,FK3异或，下面一个公式我们可以得到两个重要步骤。其中CK[i]为固定参数。\n\n第一步：是类似于32迭代运算的公式得到k[i+4]((32bit)\n\n第二步：是我们得到的这个k[i+4]赋值给了rk[i]((32bit)\n\n T′ 是将32次迭代运算中合成置换T的线性变换L替换为L′：\n![](https://i.imgur.com/dwpNmtI.png)\n系统参数FK的取值：\n![](https://i.imgur.com/V855HA8.png)\n固定参数CK具体值为：![](https://i.imgur.com/oGtEKvt.png)\n\n## 解密 ##\n本算法的解密变换与加密变换结构相同，不同的仅是轮密钥的使用顺序。解密时，使用轮密钥顺序为（rk31,rk30,...,rk0）.\n\n## 实现脚本 ##\n正在修缮中...","tags":["cryptography"],"categories":["study"]},{"title":"中关村第三届新兴领域专题赛网络与信息安全专项赛线上赛re","url":"/2019/08/23/专项赛/","content":"贴上题目：[https://pan.baidu.com/s/1CPj02KTrmNfNP6JCFRk26Q](https://pan.baidu.com/s/1CPj02KTrmNfNP6JCFRk26Q)提取码：el57\n## flat ##\n\n程序逻辑\n\n1.  check1():判断输入字符串长度是否在50以内\n\n2.  check2():判断输入字符串前几位是否为“flag{”\n\n3.  check3():最后一位是否为“}”\n\n4.  check4():14,19,23,28 是否为“-”\n\n5.  check5():字符串进行字符替换比较\n\n这里是llvm，[https://security.tencent.com/index.php/blog/msg/112](https://security.tencent.com/index.php/blog/msg/112 \"学习链接\")\n\n脚本：\n```python\na = 'J2261C63-3I2I-EGE4-IBCC-IE41A5I5F4HB'\nans = ''\n\nfor i in range(0,len(a)):\n        if(ord(a[i])>=65):\n                ans+=chr(ord(a[i])-17)\n        if(a[i]=='-'):\n                ans+=a[i]\n        if(ord(a[i])>=48):\n                if(ord(a[i])<=57):\n                        ans+=chr(ord(a[i])+48)\n\nprint ans\n```\n\n## src_leak ##\n\nfunc3<func2<x>>这个函数的意思是测试x变为2进制中x含有多少个1，且含1的个数是奇数个\n\n_fun1<x>的意思是开根号，可以根据func1<>处函数可以看出得到result的条件是L=R，而在ifelse<>函数里面当n<mid*mid时L不变，R减小；当n>=mid*mid时R不变，L变大。并且保证这几个数和是可能中的最小值，所以反推output平方即是。\n\n最后x6是1到10000有多少素数\nflag{927369-19324816-44435556-3996001-9865881-1229}","tags":["CTF"],"categories":["competition"]},{"title":"base64一些特征","url":"/2019/05/13/关于base64在逆向里面的一些特征/","content":"base64加密是逆向中常见的加密手段，但是如何发现是base64加密呢？\n\n编码原理\n\nbase64加密之后所有的字符都应该在这个表中\n![](https://i.imgur.com/EGaILLP.png)\nbase64编码是将x个8位字节变成y个6位字节然后再以00填充变成n个新的八位字节，再将二进制转换成十进制，一一替换字符。\n举个栗子：\n假设待转化的字符是 “example”\n\n转化成二进制之后得到\n\n01100101 01111000 01100001 01101101 01110000 01101100 01100101\n\nexample的长度是7因此为了使得最后得到的字符是4的倍数我们要再添上两个字符\n\n01100101 01111000 01100001 01101101 01110000 01101100 01100101 00000000 00000000\n\n然后我们将其按照6位1字符排好\n\n011001 010111 100001 100001 011011 010111 000001 101100 011001 010000 000000 000000\n\n填充00之后得到\n\n00011001 00010111 00100001 00100001 00011011 00010111 00000001 00101100 00011001 00010000 00000000 00000000\n\n再将这些二进制转换成十进制\n\n25 23 33 33 27 23 1 44 25 16 0 0\n\n对照表用字符替换之后得到\n\nZXhhbXBsZQAA\n\n再将最后的AA换成==即可\n\nZXhhbXBsZQ==\n\n","tags":["Reverse"],"categories":["study"]},{"title":"锁定文件失败 打不开磁盘“D:\\ubuntu\\Ubuntu 64 位.vmdk”或它所依赖的某个快照磁盘。 模块“Disk”启动失败。","url":"/2019/04/10/关于虚拟机锁定文件错误/","content":"\n锁定文件失败 打不开磁盘“D:\\ubuntu\\Ubuntu 64 位.vmdk”或它所依赖的某个快照磁盘。 模块“Disk”启动失败。\n\nUbuntu虚拟机非正常关闭，再次打开有时候会出现“锁定文件失败，打不开磁盘……”的错误提示\n解决办法：打开虚拟机所在路径\n删除.vmdk.lck及.vmx.lck两个文件夹中的.lck文件\n\n![](https://img-blog.csdn.net/20180918224324732?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E2ODY0NjU3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n重启就能使用了","tags":["program"],"categories":["problem"]},{"title":"2019 UTCTF","url":"/2019/04/01/UTCTF/","content":"## Low Sodium Bagel ##\n```python\n\t$ steghide extract -sf low-sodium-bagel.jpeg -p \"\"\n\twrote extracted data to \"steganopayload4837.txt\".\n\t$ cat steganopayload4837.txt\n\tutflag{b1u3b3rry_b4g3ls_4r3_th3_b3st}\n```\n关于steghide一些使用简单的爆破脚本[https://blog.csdn.net/blood_seeker/article/details/81837571](https://blog.csdn.net/blood_seeker/article/details/81837571)关于一些steghide参数介绍[https://blog.csdn.net/qq_40657585/article/details/83931078](https://blog.csdn.net/qq_40657585/article/details/83931078)\n\n## UTCTF adventure ROM ##\n这一题要感谢[dotsu师傅](https://xz.aliyun.com/t/4393)的指导，让我这个小白学到了一点东西。\n\n首先是如何打开.gb文件，使用的是Gameboy反汇编追踪工具BGB，BGB 是一款运行于windows 的GameBoy，GameBoy Color 和 Super GameBoy 。模拟器打开的界面如下：\n![](_v_images/20190401211432664_29874.png)\n开始随便转了转，就DEAD了，然后看了大佬的解释说能输入ABCD，开始找了半天输入，后来才知道要站在每个方框内按A就可以输入了，这样我们可以猜测游戏逻辑，碰到隐藏的东西会死掉，输入不对会LOSER\n\n用IDA分析文件中选择z80处理器，加载进去后还是binary文件，纠结了好久去问了dotsu师傅，最后给出了解决办法：IDA里edit->select all，然后按C键选force，这样会强制解析整个文件，但是里面的数据和字符串也会被解析为指令，可以对照着hex窗口，按A转为字符串或者按D转为数据。果然大佬就是大佬啊经验丰富，先找到放关键字的地方转字符串![](_v_images/20190401214458317_487.png)\n\n然后找到引用字符串的函数，按x不管用，search->text也不行，只能手动找了，这里是我看到放关键字符串的地方下面就是sub_73b函数所以猜测引用在sub_33E这个函数里面，看流程图就找到了引用的函数，这样我们就能知道出现DEAD的逻辑了，然后nop掉（nop方法\\x00），这样游戏的限制就没有了，同样的方法把所有的DEAD都nop掉，然后选择patch中应用到该文件中\n![](_v_images/20190401215303556_20232.png)\n\n再找到引用LOSER的函数，向上就能看到比较寄存器a，c的值，如果相等就继续循环，如果不相等就跳到LOAER处，那我们只要能弄清楚a和c谁存的是输入的，谁存的是正确值，就能拿到flag了。后面就是用gbg中的debugger来反汇编比较寄存器a，c的值，在比较处下断点，随便输入（F2下断点，F3单步执行，F9继续执行），gbg比较方便能修改寄存器的值修改指令知道结束，并把每一次寄存器c里面的值记录下来，连在一起就是flag。\n\n## mov ##\nIDA加载发现全是MOV指令，可以大概知道使用了[Movfuscator](https://github.com/xoreaxeaxeax/movfuscator)进行了混淆处理。\n\n对于复杂一些的Movfuscator程序，可以尝试根据程序中字符串等信息，配合trace工具和下断点来追踪程序流程，并猜测程序逻辑（一般来说逻辑不会特别复杂）。此外，也可以尝试使用Demovfuscator进行反混淆，运气好的话说不定会解得比较好看。（这些都是dutsu师傅写的，小白正学习中）\n\n在gdb中调试，遇到sigill信号会停住，然后发现栈中有一个字符\"u\"，再试一下就会发现utflag，继续就能得到flag。\n\n### 关于Movfuscator的学习 ###\n\n根据官方介绍Movfuscator是一个单指令C编译器（the single instruction C compiler）","tags":["CTF"],"categories":["competition"]},{"title":"2019看雪论坛ctf","url":"/2019/03/12/看雪2019/","content":"\n## 流浪者 ##\n提取码s7pn\n链接[https://pan.baidu.com/s/1xFLUjOETe9ICFdJqVTcYlw](https://pan.baidu.com/s/1xFLUjOETe9ICFdJqVTcYlw )\n\n首先题目入口函数是sub_401890，我是通过在OD里面查找字符串，找到“请输入pass”的地址，然后在IDA中找到该函数并反汇编得到了整个函数![](https://i.imgur.com/XpwZDIh.jpg)\n\n进入sub_4017F0函数通过条件得到pass\n![](https://i.imgur.com/CX9A2Qe.png)\n\n脚本如下：\n```python\n\tkey = 'KanXueCTF2019JustForhappy'\n\tstr1 = 'abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ'\n\ta1 = ''\n\tfor i in range(0,len(key)):\n\t\tfor j in range(0,62):\n\t\t\tif(str1[j] == key[i]):\n\t\t\t\tif(j >= 0):\n\t\t\t\t\tif(j <= 9):\n\t\t\t\t\t\ta1 += chr(j + 48)\n\t\t\t\tif(j >= 10):\n\t\t\t\t\tif(j <= 35):\n\t\t\t\t\t\ta1 += chr(j + 87)\n\t\t\t\tif(j >= 36):\n\t\t\t\t\tif(j <= 61):\n\t\t\t\t\t\ta1 += chr(j + 29)\t\t\n\tprint(a1)\n```\nflag是```j0rXI4bTeustBiIGHeCF70DDM```","tags":["CTF"],"categories":["competition"]},{"title":"TAMU CTF Re","url":"/2019/03/05/TAMU CTF Re/","content":"TAMU CTF 逆向有简单也有复杂的，前天刚结束，今天把这个总结一下。\n附上题目，提取码rb8r[https://pan.baidu.com/s/1A5G-pRd3oYkzVYVJDVIxvQ](https://pan.baidu.com/s/1A5G-pRd3oYkzVYVJDVIxvQ)\n\n# Cheesy #\n\n文件放到Ubuntu中运行一遍，发现采用了base64编码，把给出的加密代码解密，并没有发现flag，并且解密之后告诉你你已经错过了flag，所以考虑，是否还有未解密的隐藏代码，放到ida中发现了\n```\nZ2lnZW17M2E1eV9SM3YzcjUxTjYhfQ==\n```\n这一串密码未输出，经过解密就是flag\n```\ngigem{3a5y_R3v3r51N6!}\n```\n# Snakes over cheese #\n\n给的是一个.pyc文件，用uncompyle反编译一下得到.py文件，使用命令\n```\nuncompyle6 reversing2.pyc > reversing2.py\n```\n的得到如下的py文件，运行一下发现需要输入正确的密码才能给你flag\n不用那么麻烦的把密码给逆向出来，直接修改一下py文件直接得出flag![](https://i.imgur.com/lTqDFRF.png)\n运行结果如下：\n\n![](https://i.imgur.com/VYM1dQk.png)\n\n# 042 #\n\n这是一道真正的反汇编，给的文件不能编译所以要纯看汇编代码，但是这个汇编代码还是很简单的，前面第一个function是一个迷惑代码，实质上没用，主要看main函数，关键代码在如下地方![](https://i.imgur.com/jvvwX2N.png)\n在第二printf函数后面放入的是栈中[rbp-16]的地址，即从[rbp-16]向下取值回到上面就能看到存入栈中的值，即可获得flag\n```\ngigem{A553Mb1Y}\n```\n# keygenme #\n把enc()这个函数逆向就完了，但是有一个需要注意的地方，这里输入的a1在运行过程中strlen()函数包含了输入时的回车符'\\n'所以根据得到v5知道a1的长度应该是17，但是包含了最后的回车符，所以a1只有16个，脚本如下![](https://i.imgur.com/ffqFf4X.png)\n提交就能得到flag，比赛的时候一直没有想到这个问题，知道是多了个'Enter'但是实在没想到是这样，比赛结束后用C语言正着证明了一遍\n![](https://i.imgur.com/ckwb2Z8.png)\n![](https://i.imgur.com/Al0tO39.png)\n\n#NoCCBytes#\n放到ida里面re了一下发现答案在globPass中，显然DATA中的字符串肯定不是，但是我们可以动态调试啊，但是文件开了保护机制，所以下断点的时候要绕开这些保护机制，所以直接一点直接把断点下在字符串比较的地方。然后就看到内存中的golbpass\n![](https://i.imgur.com/XWUxGlE.png)\n满眼答案...提交就能得到flag\n","tags":["CTF"],"categories":["competition"]},{"title":"2019 Seasides CTF breakthis","url":"/2019/03/01/Seasides CTF 2019 re/","content":"这个比赛当时比的时候没找到时间，比的时候只剩最后两个小时，所以只做了两道re，nondbg这题应该比较明显按照代码的顺序把字符串正确输入就会得到flag，breakthis也很简单，验证你输入的flag是否正确，你输入的flag经过base64，rot13，uuencode加密后要跟flag_encode一样，而flag_encode已知，只要将他反过来解密就行，写这篇的意义主要是学习使用python解密\n\n附上题目，提取码fdt4[https://pan.baidu.com/s/1tyLuV8hRLemkSlsq2Wk-QQ](https://pan.baidu.com/s/1tyLuV8hRLemkSlsq2Wk-QQ)\n\n编码转换时，通常要以Unicode为中间编码，即都需要将字符串先解码（decode）成Unicode再从Unicode编码成（encode）成另一种编码\n\n如果一个字符串已经是unicode了，再进行解码则将出错,因此通常要对其编码方式是否为unicode进行判断isinstance(s, unicode) #用来判断是否为unicode \n\nuuencode是将二进制文件编码成为ascii，uudecode是用于uuencode编码的文件还原为原来的二进制文件。关于uuencode输出数据，都是以begin开头，以end结尾。begin后面644是unix档案调用的权限代码\n\n关于codecs的使用手册介绍[https://docs.python.org/3/library/codecs.html](https://docs.python.org/3/library/codecs.html)\n\n下面是解密代码，需要注意uuencode的格式\n\n![](https://i.imgur.com/4hrG4Hj.png)\n\n取得flag\n\n![](https://i.imgur.com/osrLI6O.png)\n\n附上一些可以直接用python编码和解码的一些密码，这样能大大的节约时间，但是注意python2.7和python3的区别，byte string和Unicode string编码要求在python3中的要求就更严格，在python3中区分了二进制和字符串，所以这个脚本在python3中会出现问题![](https://i.imgur.com/b6Zumt6.png)","tags":["CTF"],"categories":["competition"]},{"title":"我的二进制学习道路","url":"/2018/11/27/我的二进制学习道路/","content":"## Bin\n**前置技能**：\n\n  - 掌握汇编基础：Python、王爽《汇编语言》、虚拟机安装Ubuntu（建议版本16.4）、Linux基本操作、GDB调试、IDA调试（静态调试）（前期懂简单操作就行，后面根据视频以及使用手册再增加）\n  - 工具说明书：[GDB使用手册](https://blog.csdn.net/weiyuefei/article/details/72522973),[IDA PRO使用技巧](https://xz.aliyun.com/t/4205) ，找到比较好的可以交流一波\n\n### Pwn\n  - 基础的调试、入门首选 [LiveOverFlow](http://liveoverflow.com/binary_hacking/) （翻墙官网能自动翻译）\n  - 学习 stack overflow：明白原理，完成例题 [基本ROP](https://ctf-wiki.github.io/ctf-wiki/pwn/stackoverflow/basic_rop/)\n  - 继续完成 ctf-wiki 栈溢出部分\n\n  前面都完成的开始进阶\n  - [how2heap](https://github.com/shellphish/how2heap)\n  - [pwnable.tw](https://pwnable.tw/)、[pwnable.kr](http://pwnable.kr/play.php)\n  - CTFTime ...\n\n### Reverse\n  - 在前置技能完成后推荐找一个讲解ctf逆向题目的入门视频，一是了解ida基本的静态调试，二是增加兴趣\n  - 增加工具：虚拟机安装win7、吾爱破解Ollydug（动态调试）\n  - 推荐入门视频：[吾爱破解逆向入门套餐](https://www.52pojie.cn/thread-582852-1-1.html)(适量使用)\n  - 学习程序调试技能：逆向工程核心原理、加密解密、0day安全\n  - 可选学习教程 [reversingwithlena-tutroial](https://tuts4you.com/e107_plugins/download/download.php?action=view&id=2876) 一篇 简单的 crackme [An Intro to x86_64 Reverse Engineering](https://leotindall.com/tutorial/an-intro-to-x86_64-reverse-engineering/)\n\n  之后就是不停的练习 [crackmes](https://github.com/crackmes/crackmes) 以及内功修炼：程序开发、操作系统、编译原理 ...\n\n### 参考资料\n  - [Linux (x86) Exploit Development Series](https://sploitfun.wordpress.com/2015/06/26/linux-x86-exploit-development-tutorial-series/)\n  - [Linux (x86) Exploit 开发系列教程](https://bbs.pediy.com/thread-217390.htm)\n  - windows平台： [Exploit writing tutorial part 1 : Stack Based Overflows](https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/)、[Part 1: Introduction to Exploit Development](https://www.fuzzysecurity.com/tutorials/expDev/1.html)\n  - [exploit入门级](http://martin.uy/blog/projects/reverse-engineering/)\n  - [一步一步学ROP x86](http://www.vuln.cn/6645)\n  - 论坛：看雪、吾爱、tuts4you**（逛论坛很重要，大佬，学习资料，工具，题解，不懂的问题都能找到）**\n# Reference\n- [Web-Security-Learning](https://github.com/CHYbeta/Web-Security-Learning) （较好的web安全相关学习资源）\n- [CTF-All-In-One](https://github.com/firmianay/CTF-All-In-One) （一本 CTF 领域的大杂烩指南）\n- [Awesome-Hacking](https://github.com/Hack-with-Github/Awesome-Hacking) （非常全面的黑客技术清单）\n- [CTF-Wiki](https://ctf-wiki.github.io/ctf-wiki/) （CTF的入门简介）","tags":["Reverse"],"categories":["study"]},{"title":"关于逆向学习的一些知识","url":"/2018/11/23/逆向学习/","content":"\nAPI：API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。\nAPI函数包含在Windows系统目录下的**动态连接库**文件中。。API说来说去，就是一种函数，他们包含在一个附加名为DLL的动态连接库文件中。Windows API是一套用来控制Windows的各个部件的外观和行为的预先定义的Windows函数。用户的每个动作都会引发一个或几个函数的运行以告诉Windows发生了什么。这在某种程度上很像Windows的天然代码。而其他的语言只是提供一种能自动而且更容易的访问API的方法。当你点击窗体上的一个按钮时，Windows会发送一个消息给窗体，VB获取这个调用并经过分析后生成一个特定事件。\n更易理解来说：Windows系统除了协调应用程序的执行、内存的分配、系统资源的管理外，同时他也是一个很大的服务中心。调用这个服务中心的各种服务(每一种服务就是一个函数)可以帮助应用程序达到开启视窗、描绘图形和使用周边设备等目的，由于这些函数服务的对象是应用程序，所以称之为Application Programming Interface，简称API 函数。WIN32 API也就是MicrosoftWindows 32位平台的应用程序编程接口。\n凡是在 Windows工作环境底下执行的应用程序，都可以调用Windows API。\n其实就是用户指令先由编程语言编程成电脑能读懂的语言，这个语言能自动的更快的访问API，这样应用程序通过API与Windows某些部件连接起来，让Windows内部运作起来完成用户指令，并返回给用户界面。API是应用程序接口。你可以在其他的程序中，通过一定的规范通过API发送信息给另一个程序，并接收返回的结果。看了很多，一个很有意思的回答是，双方交流的暗号\n\nvc6入口代码特征：都是push ebp；mov ebp，esp类似的；入口调用API也是相同的\nvc6的四个区段：.text代码段.rdata导入表（只读数据段）.data数据段.rsrc资源段\nvs2008和vs2013相较于vc6：入口代码只有两行，vs2018是一个call后面接一个jmp，第一个call里面进去后也是push ebp啥啥的，调用的API也相同\nVB启动代码：jmp ThunRTMain();push RT_MainStruct结构体函数地址；call (jum ThunRTMain()地址);前面压入栈的的值作为ThunRTMain()函数参数\n\n易语言（非独立编译）：编译时很明显的运行库文件，入口特征和模块特征都有krnln.fnr，易语言支持库有.fnr格式,.fne格式和.npk格式\n\nOD被压缩后分析：ctrl+A\n加aspack壳的特征：入口特征pushad，一个call和jmp，并且会增加两个区段\n\n加UPX壳后特征：\n\nhttps://www.cnblogs.com/Fightingbirds/p/3172907.html ","tags":["Reverse"],"categories":["study"]},{"title":"2018i春秋骇极杯what","url":"/2018/11/07/2018i春秋骇极杯what/","content":"骇极杯第二个逆向，也不难，也是两个函数，首先是爆破MD5，然后进行动态解密check函数\n\n这是结束几天之后，我再来写的wp，我开始觉得很简单的，后来看了详细的过程之后我觉得我还是有很多却缺陷的，下面开始一步一步分析\n\n首先拖进ida，主要分两部分来看：\n![](https://i.imgur.com/SgicMs0.png)\n\n要先得到luck string才能获得check函数的内容，所以先对MD5进行爆破\n\n\t```python\n\timport hashlib\n\tfor a1 in range(97,123):\n\t\tfor a2 in range(97,123):\n\t\t\tfor a3 in range(97,123):\n\t\t\t\tfor a4 in range(97,123):\n\t\t\t\t\tfor a5 in range(97,123):\n\t\t\t\t\t\tfor a6 in range(97,123):\n\t\t\t\t\t\t\tasc=hashlib.md5((char(a1)+char(a2)+char(a3)+char(a4)+char(a5)+char(a6)).encode('ascii')).hexdigest()\n\t\t\t\t\t\t\tv5=0\n\t\t\t\t\t\t\tv4=0\n\t\t\t\t\t\t\tfor i in range(32):\n\t\t\t\t\t\t\tif(asc[i]=='0'):\n\t\t\t\t\t\t\t\tv5+=1\n\t\t\t\t\t\t\t\tv4+=i\n\t\t\t\t\t\t\tif(10*v5+v4==403):\n\t\t\t\t\t\t\t\tprint(chr(a1)+chr(a2)+chr(a3)+chr(a4)+chr(a5)+chr(a6))\n\t```\n\n脚本我放在虚拟机里面跑了半个小时，最后得出了luck string = `ozulmt`。\n\n再弄出v4和v5\n\t\n\t","tags":["CTF"],"categories":["competition"]},{"title":"2018网鼎杯之beijing","url":"/2018/11/06/2018网鼎杯之beijing/","content":"题目不难，但是我不会写脚本，学习的大佬的先贴上地址，稍后来写[https://blog.csdn.net/re_psyche/article/details/81947537](https://blog.csdn.net/re_psyche/article/details/81947537)","tags":["CTF"],"categories":["competition"]},{"title":"关于git bash无法上传更新博客","url":"/2018/11/06/关于git bash无法上传/","content":"  之前blog不知道出了什么问题一直显示上传成功，却依旧不能更新，后来才发现问题，如图：![](https://i.imgur.com/g7kV8OY.png)\n  \n  **配置缺少GitHub邮箱和用户名**.....好的吧，加上加上\n  ![](https://i.imgur.com/fw81xiO.png)\n\n  上传文件到远程仓库\n![](https://i.imgur.com/L7v7FHm.png)","tags":["problem"],"categories":["problem"]},{"title":"2018i春秋骇极杯cpp","url":"/2018/11/04/i春秋骇极杯reverse/","content":"逆向呢真的是一边学一边写题过来的，我比较喜欢这样\n贴上题目[https://pan.baidu.com/s/1KDQs81aqUYl7T7E9mZO-SQ](https://pan.baidu.com/s/1KDQs81aqUYl7T7E9mZO-SQ)\n## C plus plus##\n拖到IDA里面看一看，发现main函数里面有两个特别重要的加密函数，点击进去看看![](https://i.imgur.com/xbpOf3D.png)\n因为正在学c++所以呢，就去把basic_ string这个类去看了一下（真的是萌新要学习的东西很多呢）\n\n贴上学习的地址，个人更偏向英文版，英文版：[http://www.cplusplus.com/reference/string/basic_string/basic_string/](http://www.cplusplus.com/reference/string/basic_string/basic_string/)\n中文版：[https://blog.csdn.net/hl156/article/details/80610597](https://blog.csdn.net/hl156/article/details/80610597)\n\n**basic_ string(char &s1,char &s2)**是把s2字符串赋值给s2；若是**basic_string(char &s1,int n)**是打印出s1前n个字符，以字符串的形式；**basic _string(char &s1,int n,int m**)若n<m是打印出s[n]到s[m]之间的字符串,若n>m是打印出s[n]后面m个字符（都包括s[n]）；**basic _string(int n,'a')**是打印n个a出来，等等....\n**~basic_string()**则是删除这个字符串\n**operate[](a1,i)**就是取字符串第i位的字符出来\n**c-str()**返回指向数组的指针，该数组包含表示basic _string对象当前值的以空字符结尾的字符序列（即C字符串）。即此数组包含构成basic _string对象的值的相同字符序列以及末尾的附加终止空字符（charT（））。下面代码助于理解，其中strtok这个函数下面是他的固定格\n\n![](https://i.imgur.com/Py02Hsg.png)\n好了，好了废话太多了\n\n以下是第一个加密函数![](https://i.imgur.com/NWKv9G1.png)\n经过调试无论如何都会通过第一加密函数的，第一个是简单的异或与位移所以算法就是左移数组六位|右移数组两位再按位异或\n\n第二个加密函数就比较复杂\n我调试了之后大概意思是跟前面一个异或\n\n下面是我的脚本，参考了大佬（[Mr.Riscker](https://mmmmmmlei.cn/2018/11/05/上海市大学生网络安全大赛/ \"Mr.Riscker\"))的代码的，觉得很简洁\n\n![](https://i.imgur.com/vWyHDsM.png)\n\n当当当，flag如下\n\n![](https://i.imgur.com/kG6im6q.png)\n\n偶然在吾爱论坛上找到了一个讲解及其细致的wp，很适合我这种新人看啊贴上地址[https://www.52pojie.cn/thread-819393-1-1.html](https://www.52pojie.cn/thread-819393-1-1.html)\n\n里面讲到了之前我没有注意到的几点，我重新加上：\n\n1. a<<2这个从哪里来：在ida上面第一个函数中有`v2 = 4 * *(char *)std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator[](a1, i);`这个并不是讲a1*4而是在进行\"a<<2\"的操作\n2. 代码中的&0xff：第一个加密函数进行了a[i]=(a[i]<<2|a[i]>>6)^i这样的一个操作，但是异或i这一步跑不出来，所以还要加上&0xff才行，byte类型的数字要&0xff再赋值给int类型，是想保持二进制补码的一致性（数据在计算机中存储是以二进制的方式，正数存储的二进制原码,负数存储的是二进制的补码，补码是负数的绝对值反码加1）","tags":["CTF"],"categories":["competition"]},{"title":"初学PWN---栈溢出","url":"/2018/10/12/初学pwn之栈溢出/","content":"经过百转千回弯弯绕绕我这个可爱的程序媛最终还是屈服在PWN的淫威下，接下来的内容是我PWN入门的一些知识，如果有什么知识性的错误，请大方指出来，给你奖励小发发❀\n\n首先，在学PWN之前我学了**C语言**和**汇编语言**，还了解一点**python**和**Linux系统**的基本操作，并且也有一点点**逆向工程** 的基础，学PWN主要是看**YouTube**上面一个声音巨好听的美国不露面小哥哥的视频，这个小哥哥三年前也是一边自学PWN一边录视频，讲的很基础好懂又幽默有趣，最近看到小哥哥去了拉斯维加斯参加**defcon** 和**blackhat**，而且那个小哥哥竟然还是个学生，无数次感觉输在了人生的起跑线上呢，我也才上大学，他在上大学就知道那么多知识，而我还只是个萌新呢，一起加油~~（暗戳戳的说一句，感觉那个小哥哥长得好高啊，对我来说高=帅）\n\n废话不多说，贴上视频地址[http://liveoverflow.com/](http://liveoverflow.com/ \"liveoverflow\")\n## stack0~4 ##\n这几个原理基本是差不多的，通过栈溢出将某值改变或者覆盖返回地址\n### 0~4的答案和需要注意的地方 ###\n**stack0**\n主要讲的是覆盖掉modified的值让它不等于0即可，那我们首先找到buff的地址和modified的地址\n`0x080483fd <main+9>: movl $0x0,0x5c(%esp)`为modified的地址\n\n(```)\n0x08048405 <main+17>:   lea    0x1c(%esp),%eax\n0x08048409 <main+21>:   mov    %eax,(%esp)\n(```)是buff的地址\n两个地址0x5c和0x1c相差0x40个字节再加上0X1个需要覆盖的字节\n\n*\t代码如下：\n\n\t\t$ python -c 'print \"A\"*0x40+\"\\x01\\x00\\x00\\x00\"' | ./stack\n\t\tyou have changed the 'modified' variable\n\n**stack1**\n让modified的地址等于0x61626364,思路同上题，不过要**注意**的是x86系列的电脑都是采用**小端序**的方式储存数据。\n\n*\t小端序和大端序：\n\n\t>小端序：字数据的低字节存储在低地址中。\n\t>大端序：字数据的高字节存储在低地址中。\n\n*\t代码如下：\n\n\t\t./stack1 $python -c 'print \"A\"*0x40+\"dcba\"'\n\t\tyou have correctly got the variable to the right value\n\n**stack2**\n此处需要设置环境变量GREENIE\n\n*\t代码如下：\n\n\t\t$ GREENIE=`python -c 'print \"A\"*0x40+\"\\x0a\\x0d\\x0a\\x0d\"'\n\t\t$ export GREENIE\n\t\t$ ./stack2\n\t\tyou have correctly modified the variable\n\n**stack3**\n此处我们需要跳到win函数处，首先获得win函数的地址:\n\n`(gdb)print win`得到`$1 = {void (void)} 0x8048424 <win>`\n获得地址之后直接覆盖fp\n\n*\t代码如下：\n\n\t\t$python -c 'print \"A\"*0x40+\"\\x24\\x84\\x04\\08\"' | ./stack3\n\t\tcalling function pointer, jumping to 0x08048424\n\t\tcode flow successfully changed\t\t\n\n**stack4**\n覆盖返回地址让他跳到win函数就行了，注意这里要多覆盖0x1字节，偏移为0x4c\n\n*\t代码如下：\n\n\t\t$ python -c 'print \"A\"*0x4C+\"\\xf4\\x83\\x04\\x08\"' | ./stack4\n\t\tcode flow successfully changed\n\t\tSegmentation fault\n## stack5 ##\n\n首先介绍shellcode：Shellcode实际是一段代码（也可以是填充数据），是用来发送到服务器利用特定漏洞的代码，一般可以获取权限。另外，Shellcode一般是作为数据发送给受攻击服务器的\n\n再介绍int 3（CC）：当被调试进程执行INT3指令导致一个异常时，调试器就会捕捉这个异常从而停在断点处，然后将断点处的指令恢复成原来的指令用INT3断点的好处是可以设置无数个断点，缺点是改变了原程序指令，容易被软件检测到。例如为了防范API被下断，一些软件会检测API的首地址是否为CCh，以此来判断是否被下了断点但是如果将断点下在函数的内部或者末尾，例如可以将断点下在函数入口的下一行，就可以躲过检测了\n\n再来说说整个做题的想法，代码极其简单，但是我思考了很久为什么要这么做，暂时无果，按照视频所讲通过在缓存区放入shellcode通过管道传输给stack5，然后得到root权限\n\nShellcode放在返回地址后面，前面跟上NOP Slot；这可以消除缓冲区位置的不确定性。 \n\n注意:非GDB运行和GDB运行，缓冲区的地址会有变化\n注意：这里使用的”()”会生成一个子shell；\n\n子shell中执行两条命令。\n\n第一条命令将payload输出到标准输出，通过管道传输给stack5；\n\n第二个命令cat从标准输入中读取数据输出到标准输出，也会通过管道传输给stack5；\n\n__ builtin_ return_ address(0)的含义是，得到当前函数返回地址，即此函数被别的函数调用，然后此函数执行完毕后，返回，所谓返回地址就是那时候的地址。_builtin_return_address(1)的含义是，得到当前函数的调用者的返回地址。注意是调用者的返回地址，而不是函数起始地址。利用__builtin_return_address来获得函数运行栈的方法。\n","tags":["PWN"],"categories":["study"]},{"title":"2018看雪论坛ctf第一题","url":"/2018/07/28/2018看雪论坛第一道题/","content":"\n  这是long long ago 以前的CTF简单的解题思路，刚开始接触的逆向工程，所以从简单的开始吧！（ps：下一篇应该是iscc逆向Reverse题解，这是我做出来的第一个逆向工程题）\n\n##2018看雪CTF之XCTF##\n\n  此处贴上题目：[https://pan.baidu.com/s/15AJ5rXllWDwMhsX2dUKHyQ](https://pan.baidu.com/s/15AJ5rXllWDwMhsX2dUKHyQ)\n\n  首先打开.exe文件可以看到如下：![](https://i.imgur.com/7caoScF.png)\n\n  要求输入正确的序列号......\n\n  正常情况下我们拖到OD里面看一下，找到关键句：\n  \n  ![](https://i.imgur.com/IGY118b.png)\n  \n   进入之后，随便输入一个值先调试一下：\n   \n  ![](https://i.imgur.com/p68Vpda.png)\n   \n   此时我们需要找到关键跳转，在关键跳转处下断点：\n  \n  ![](https://i.imgur.com/qjdbUyY.png)\n  \n   下完断点后，直接运行到断点处，发现寄存器这边多了一个ASCII码值，此值就是我们要找到的值：\n\n  ![](https://i.imgur.com/FjU4ID0.png)\n\n   这个时候我们把这个值输进去，明显不对，想到可能是16进制转字符串，得到答案：\n\n   ![](https://i.imgur.com/ZWR8EN5.png)\n\n\n   没错！！！答案就是如此简单，hhhh....","tags":["CTF"]}]