[{"url":"/2021/01/29/01.26学习/","content":"# 01.26学习\n\n## ActivityLifecycleCallbacks监听自己应用Activity的生命周期\n\nregisterActivityLifecycleCallbacks，提供了一个应用生命周期回调的注册方法，用来对应用的生命周期进行集中管理，可以通过它注册自己的ActivityLifeCycleCallback，每一个Activity的生命周期都会回调到这里的对应方法。因此使用ActivityLifecycleCallbacks，应用中的所有的activity会在每个生命周期调用ActivityLifecycleCallbacks里面相对应的方法。\n\n因此这个方法可以拿来做log日志工具\n\nhttps://blog.csdn.net/u010072711/article/details/77090313\n\nhttps://blog.csdn.net/tongcpp/article/details/40344871\n\n## getNetworkInfo\n\n获取手机是否连网，其中有的代码用到了ConnectivityManager 的getNetworkInfo函数，但是最近发现getNetworkInfo已经过时\n\nhttp://www.jishudog.com/14708/html\t\n\n## permission\n\n在近期分析拉活的时候看到了`<permission>``<ueser-permission>`\n\n大概总结一下，就是 `<permission>` 标签用来声明、定义一个权限,这个权限可以供其他应用程序调用，而 `<uses-permission>` 标签用来申请一个权限，声明你需要该权限"},{"url":"/2021/01/29/10.30学习/","content":"# 10.30学习\n\n## android:exported\n\nandroid:exported是Android中的四大组件 Activity，Service，Provider，Receiver 四大组件中都会有的一个属性。\n\n总体来说它的主要作用是：是否支持其它应用调用当前组件。\n默认值：如果包含有intent-filter 默认值为true; 没有intent-filter默认值为false。\n\n## BroadcastReceiver 学习\n\n程序启动BroadcastReceiver 的步骤\n\n1.创建需要启动的BroadcastReceiver 的intent\n\n2.调用context的sendBroadcast（）或SendOrderedBroadcast（）方法来启动指定的BroadcastReceiver。其中`sendBroadcast`发送的是普通广播，`sendOrderedBroadcast`发送的是有序广播。\n\n创建BroadcastReceiver\n\n第一步：创建BroadcastReceiver的子类：\n\n​    由于BroadcastReceiver本质上是一种监听器，所以创建BroadcastReceiver的方法也非常简单，只需要创建一个BroadcastReceiver的子类然后重写onReceive (Context context, Intentintent)方法即可。\n\n```\npublic class MyBroadcastReceiver extends BroadcastReceiver {\n         @Override\n         public void onReceive(Context context, Intent intent) {\n                   // TODO Auto-generated method stub\n                   String msg=intent.getExtras().get(\"msg\").toString();\n                   Toast.makeText(context,\"intent.getAction()\"+intent.getAction().toString(),\n                                     Toast.LENGTH_LONG).show();\n                   System.out.println(\"msg:\"+msg);\n         }\n}\n```\n\n\n第二步：注册BroadcastReceiver\n\n   一旦实现了BroadcastReceiver，接下就应该指定该BroadcastReceiver能匹配的Intent即注册BroadcastReceiver。注册BroadcastReceiver的方式有两种：\n\n***\\*第一种是静态注册\\****：这种方法是在配置AndroidManifest.xml配置文件中注册，通过这种方式注册的广播为常驻型广播，也就是说如果应用程序关闭了，有相应事件触发，程序还是会被系统自动调用运行。例如：\n\n```\n<!-- 在配置文件中注册BroadcastReceiver能够匹配的Intent -->\n<receiver android:name=\"com.example.test.MyBroadcastReceiver\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.MyBroadcastReceiver\"></action>\n        <category android:name=\"android.intent.category.DEFAULT\"></category>\n    </intent-filter>\n</receiver> \n\n```\n\n***\\**\\*第二种是动态注册\\*\\**\\***：这种方法是通过代码在.Java文件中进行注册。 通过这种方式注册的广播为非常驻型广播，即它会跟随 Activity 的生命周期，所以在 Activity 结束前我们需要调用 unregisterReceiver(receiver) 方法移除它。例如：\n\n```\n//通过代码的方式动态注册MyBroadcastReceiver\nMyBroadcastReceiver receiver=new MyBroadcastReceiver();\nIntentFilter filter=new IntentFilter();\nfilter.addAction(\"android.intent.action.MyBroadcastReceiver\");\n//注册receiver\nregisterReceiver(receiver, filter);\n```\n\n***\\**\\*注意：\\*\\**\\***如果我们在Activity中注册了BroadcastReceiver，当这个Activity销毁的时候要主动撤销注册否则会出现异常。 方法如下：\n\n```\n @Override\n         protected void onDestroy() {\n                   // TODO Auto-generated method stub\n                   super.onDestroy();\n                   //当Activity销毁的时候取消注册BroadcastReceiver\n                   unregisterReceiver(receiver);\n         }\n\n```\n\n\n\n## Android之standout（浮动窗口）\n\n[StandOut ](http://pingpongboss.github.com/StandOut/)是一个在Android应用中创建浮动窗口的框架，使用该框架可以方便的创建各种浮动窗口。可以指定窗口大小、放置的位置、是否可以拖动、是否可以最小化、可以在通知栏显示提示等等。\n\n只要继承 wei.mark.standout.StandOutWindow类 ，重写（Override）各种函数即可。\n\n```\npublic class FloatingFoldersLauncher extends Activity {  \n    /** Called when the activity is first created. */  \n    @Override  \n    public void onCreate(Bundle savedInstanceState) {  \n        super.onCreate(savedInstanceState);  \n  \n        StandOutWindow.closeAll(this, FloatingFolder.class);  \n        FloatingFolder.showFolders(this);  \n          \n        finish();  \n    }  \n}  \n```\n\n实例项目StandOutExample：\n\n```\npublic class StandOutExampleActivity extends Activity {  \n    /** Called when the activity is first created. */  \n    @Override  \n    public void onCreate(Bundle savedInstanceState) {  \n        super.onCreate(savedInstanceState);  \n  \n        StandOutWindow.closeAll(this, SimpleWindow.class);  \n        StandOutWindow.closeAll(this, MultiWindow.class);  \n        StandOutWindow.closeAll(this, WidgetsWindow.class);  \n  \n        // show a MultiWindow, SimpleWindow  \n  \n        StandOutWindow  \n                .show(this, SimpleWindow.class, StandOutWindow.DEFAULT_ID);  \n        StandOutWindow.show(this, MultiWindow.class, StandOutWindow.DEFAULT_ID);  \n        StandOutWindow.show(this, WidgetsWindow.class,  \n                StandOutWindow.DEFAULT_ID);  \n  \n        // show a MostBasicWindow. It is commented out because it does not  \n        // support closing.  \n  \n        /*  \n         * StandOutWindow.show(this, StandOutMostBasicWindow.class,  \n         * StandOutWindow.DEFAULT_ID);  \n         */  \n  \n        finish();  \n    }  \n}\n```\n\n```\npublic class MostBasicWindow extends StandOutWindow {  \n  \n    @Override  \n    public String getAppName() {  \n        return \"MostBasicWindow\";  \n    }  \n  \n    @Override  \n    public int getAppIcon() {  \n        return android.R.drawable.btn_star;  \n    }  \n  \n    @Override  \n    public void createAndAttachView(int id, FrameLayout frame) {  \n        TextView view = new TextView(this);  \n        view.setText(\"MostBasicWindow\");  \n        view.setBackgroundColor(Color.CYAN);  \n  \n        frame.addView(view);  \n    }  \n  \n    @Override  \n    public StandOutLayoutParams getParams(int id, Window window) {  \n        return new StandOutLayoutParams(id, 200, 150, 100, 100);  \n    }  \n}  \n```\n\n"},{"url":"/2021/01/29/01.21学习/","content":"# queryBroadcastReceivers\n\n### queryBroadcastReceivers\n\n在[API级别1中](https://developer.android.com/guide/topics/manifest/uses-sdk-element#ApiLevels)添加\n\n```\n公共抽象列表< ResolveInfo > queryBroadcastReceivers（Intent，\n                int ，int标志）\n```\n\n检索所有可以处理给定意图广播的接收器。\n\n\n\n| 参数     |                                                              |\n| :------- | ------------------------------------------------------------ |\n| `intent` | `Intent`：根据resolveActivity（）所需的意图。此值不能为`null`。 |\n| `flags`  | `int`：附加选项标志，用于修改返回的数据。值可以是`0`或的组合，，，，android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING， ，，，，，，， ，android.content.pm.PackageManager.MATCH_INSTANT， ，，和`GET_META_DATA``GET_RESOLVED_FILTER``GET_SHARED_LIBRARY_FILES``MATCH_ALL``MATCH_DISABLED_COMPONENTS``MATCH_DISABLED_UNTIL_USED_COMPONENTS``MATCH_DEFAULT_ONLY``MATCH_DIRECT_BOOT_AUTO``MATCH_DIRECT_BOOT_AWARE``MATCH_DIRECT_BOOT_UNAWARE``MATCH_SYSTEM_ONLY``MATCH_UNINSTALLED_PACKAGES``GET_DISABLED_COMPONENTS``GET_DISABLED_UNTIL_USED_COMPONENTS``GET_UNINSTALLED_PACKAGES` |\n\n| 返回                |                                                              |\n| :------------------ | ------------------------------------------------------------ |\n| `List<ResolveInfo>` | 返回一个ResolveInfo对象的列表，该列表包含每个匹配接收者的一个条目，从最佳到最坏的顺序排列。如果没有匹配的接收者，则返回一个空列表或null。 |\n\nhttps://developer.android.com/reference/android/content/pm/PackageManager\n\n\n\n"},{"url":"/2021/01/29/10.28学习/","content":"# 10.28学习\n\n样本分析\n\n监听home键，注册联系人监听器并获得联系人信息\n\n![QQ图片20210129180238](E:\\blog图片\\QQ图片20210129180238.png)\n\n获取通讯录并上传并向通讯录人发送信息\n\n![img](file:///C:\\Users\\Administrator\\AppData\\Roaming\\Tencent\\Users\\1092960149\\TIM\\WinTemp\\RichOle\\Z9$UZV4G3L_Q9}8`ZON5SUO.png)\n\n![QQ图片20201028182642](E:\\blog图片\\QQ图片20201028182642.png)\n\n将本程序替换程序默认sms\n\n![image-20201028183023352](E:\\blog图片\\image-20201028183023352.png)\n\n从在线地址获取手机号码和下载地址\n\n![image-20201028183258909](E:\\blog图片\\image-20201028183258909.png)\n\n在线地址加解密处\n\n![image-20201028183453837](E:\\blog图片\\image-20201028183453837.png)\n\n为了加深理解，自己尝试写了一个获取联系人信息的demo\n\n```java\npackage com.example.sms;\n\nimport androidx.appcompat.app.AppCompatActivity;\n\nimport android.content.ContentResolver;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.provider.ContactsContract;\nimport android.widget.ListView;\n\npublic class MainActivity extends AppCompatActivity {\n\n    private ListView listView;\n    private ContentResolver cr;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        getMsgs();\n        getContacts();\n    }\n\n    private void getMsgs() {\n        Uri uri = Uri.parse(\"content://sms/\");//短信信息存储地址\n        ContentResolver resolver = getContentResolver();\n        //获取的是哪些列的信息\n        Cursor cursor = resolver.query(uri, new String[]{\"address\",\"date\",\"type\",\"body\"}, null, null, null);\n        //Cursor数据库每行的集合\n        while(cursor.moveToNext())\n        {\n            String address = cursor.getString(0);\n            String date = cursor.getString(1);\n            String type = cursor.getString(2);\n            String body = cursor.getString(3);\n            System.out.println(\"地址:\" + address);\n            System.out.println(\"时间:\" + date);\n            System.out.println(\"类型:\" + type);\n            System.out.println(\"内容:\" + body);\n            System.out.println(\"======================\");\n        }\n        cursor.close();\n    }\n    private void getContacts(){\n        //①查询raw_contacts表获得联系人的id\n        ContentResolver resolver = getContentResolver();\n        Uri uri = ContactsContract.CommonDataKinds.Phone.CONTENT_URI;\n        //查询联系人数据\n        Cursor cursor = resolver.query(uri, null, null, null, null);\n        while(cursor.moveToNext())\n        {\n            //获取联系人姓名,手机号码\n            String cName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));\n            String cNum = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));\n            System.out.println(\"姓名:\" + cName);\n            System.out.println(\"号码:\" + cNum);\n            System.out.println(\"======================\");\n        }\n        cursor.close();\n    }\n}\n```\n\n"},{"url":"/2021/01/29/12.02学习/","content":"# 12.02学习\n\n## activity-alias标签元素\n\n此标签是在看马甲包应用的时候看到的。参考链接https://blog.csdn.net/ahence/article/details/51648768\n\n功能\n\nactivity-alias为一个已经存在的Activity创建一个别名，作用是可以通过该别名标签声明快速打开目标Activity，因此activity-alias可以用来设置某个Activity快捷入口可以放在桌面上或者通过该别名被其他组件快速调起。\n\n该标签元素支持一些属性及intent-filter、meta-data等配置，因此可以触发一些跟目标Activity不同的功能逻辑，虽然打开的是同一个Activity。**举个简单的例子**，如之前需要先打开主界面，然后才能点击进入某个Activity，如果使用activity-alias为该Activity配置一个快捷入口，甚至可以为其在桌面生成一个图标，然后点击桌面图标可直接进入该Activity，该功能可满足某些需要快速到达功能界面的需求。\n\n**以上，此标签可以替换图标，再结合setComponentEnabledSetting ，可以做到隐藏原本的应用的图标，替换成新的图标，从而达到隐藏真是app的作用，这样就成为了一个马甲包应用。**\n\n重要属性：\n\n1. android:icon 该属性**允许自定义icon**，可以不同于应用本身在桌面的icon。如果需要在桌面上创建快捷入口，也许产品会要求换个不同的icon。\n2. android:label 该属性类似于android:icon，图标都换了，换个名称也合情合理吧，此属性就是换一个桌面应用名称。\n3. android:name 该属性可以为任意字符串，但最好符合类名命名规范。activity元素的name属性实质上都会指向一个具体的Activity类，而**activity-alias的name属性仅作为一个唯一标识而已**。\n\n## setComponentEnabledSetting方法 \n\n该方法是禁用和开启组件的方法，也是看马甲包应用的时候看到的，可以隐藏一个app的图标，显示另一个图标。参考链接https://blog.csdn.net/mingli198611/article/details/17269355\n\n`public void setComponentEnabledSetting (ComponentName componentName, int newState, int flags)`\n\n`componentName：组件名称` \n\n`newState：组件新的状态，可以设置三个值，分别是如下：` \n` 不可用状态：COMPONENT_ENABLED_STATE_DISABLED` \n` 可用状态：COMPONENT_ENABLED_STATE_ENABLED` \n` 默认状态：COMPONENT_ENABLED_STATE_DEFAULT` \n\n`flags:行为标签，值可以是DONT_KILL_APP或者0。 0说明杀死包含该组件的ap`\n\n## Context.getExternalFilesDir()和Context.getExternalCacheDir()\n\n这两个方法是获取目录的方法，一般用在app内下载apk包时或者查找使用文件时会用到。\n\n**Context.getExternalFilesDir()**方法可以获取到 SDCard/Android/data/你的应用的包名/files/ 目录，一般放一些长时间保存的数据\n**Context.getExternalCacheDir()**方法可以获取到 SDCard/Android/data/你的应用包名/cache/目录，一般存放临时缓存数据"},{"url":"/2021/01/29/11.05学习/","content":"# 11.05学习\n\n## 定位信息获取\n\n写了一个定位获取的功能应用，模拟一下app获取定位时具体代码实现\n\n```\npackage cn.twle.android.GPSUpdate;\n\nimport androidx.annotation.NonNull;\nimport androidx.appcompat.app.AppCompatActivity;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.location.Location;\nimport android.location.LocationListener;\nimport android.location.LocationManager;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.provider.Settings;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport static android.Manifest.permission.ACCESS_FINE_LOCATION;\n\npublic class MainActivity extends AppCompatActivity {\n\n    private LocationManager lm;\n    private TextView ms_msg;\n    private String loc_msg;\n\n    private Handler handler = new Handler(new Handler.Callback() {\n        @Override\n        public boolean handleMessage(@NonNull Message msg) {\n            if(msg.what == 0x001){\n                ms_msg.setText(loc_msg);\n            }\n            return false;\n        }\n    });\n\n    private LocationListener mLocationListener = new LocationListener() {\n        @Override\n        public void onLocationChanged(@NonNull Location location) {\n            updataShow(location);\n        }\n    };\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        ms_msg = (TextView)findViewById(R.id.ms_msg);\n\n        lm = (LocationManager)getSystemService(Context.LOCATION_SERVICE);\n\n        locationUpdata();\n    }\n    public void onResume(){\n        super.onResume();\n        locationUpdata();\n    }\n    public void onPause()\n    {\n        super.onPause();\n        lm.removeUpdates(mLocationListener);\n    }\n    public void locationUpdata(){\n        if(checkCallingOrSelfPermission(ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED){\n            Toast.makeText(MainActivity.this,\"请打开GPS\",Toast.LENGTH_SHORT).show();\n\n            Intent intent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS);\n            startActivityForResult(intent,0);\n            return;\n        }\n        Location location = lm.getLastKnownLocation(LocationManager.NETWORK_PROVIDER);\n        updataShow(location);\n        lm.requestLocationUpdates(LocationManager.GPS_PROVIDER,2000,8,mLocationListener);\n    }\n\n    private void updataShow(Location location) {\n        if(location != null){\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"当前位置信息:\\n\");\n            sb.append(\"精度：\"+location.getLongitude()+\"\\n\");\n            sb.append(\"纬度\"+location.getLatitude()+\"\\n\");\n            sb.append(\"高度\"+location.getAltitude()+\"\\n\");\n            sb.append(\"定位精度：\"+location.getAccuracy()+\"\\n\");\n\n            loc_msg = sb.toString();\n        }\n        else\n            loc_msg = \"\";\n        handler.sendEmptyMessage(0x001);\n    }\n\n}\n```\n\n## 成果展示:\n\n![image-20201204183508543](E:\\blog图片\\image-20201204183508543.png)\n\n"},{"url":"/2021/01/29/10.27学习/","content":"# 10.27学习\n\n## apk结构\n\nMETA-INF目录：存放签名，用来保证apk包的完整性和系统安全\n\nassets目录：用于存放需要打包到APK中的静态文件。res目录下的文件会在.R文件中生成对应的资源ID，assets不会自动生成对应的ID，访问的时候需要AssetManager类。\n\nlib目录：这里存放应用程序依赖的native库文件，一般是用C/C++编写，这里的lib库可能包含4中不同类型，根据CPU型号的不同，大体可以分为ARM架构，ARM-V7a架构，MIPS架构和X86架构。\n\nres目录：存放资源文件，存在这个文件夹下的所有文件都会映射到Android工程的.R文件中，生成对应的ID，访问的时候直接使用资源ID即R.id.filename，res文件夹下可以包含多个文件夹。\n\nAndroidMainfes.xml：是Android应用程序的配置文件，开发Android应用程序的时候，一般都把代码中的每一个Activity，Service，Provider和Receiver在AndroidManifest.xml中注册，只有这样系统才能启动对应的组件，另外这个文件还包含一些权限声明以及使用的SDK版本信息等等。程序打包时，会把AndroidManifest.xml进行简单的编译，便于Android系统识别，编译之后的格式是AXML格式。\n\nclasses.dex ：.class文件：Java文件编译生成的的字节码都保存在其中，一个类生成一个class文件\n\n​\t\t\t\t\t\t .dex文件：先生成class文件，Android应用在打包时通过AndroidSDK中dx工具将java字节码转换成Dalvik字节码，dx工具可以对多个class文件进行合并，重组，优化。\n\nresources.arsc：用来记录资源文件和资源id之间的映射关系，用来根据资源id寻找资源。Android的开发是分模块的，res目录专门用来存放资源文件，当在代码中需要调用资源文件时，只需要调用findviewbyId()就可以得到资源文件，每当在res文件夹下放一个文件，aapt就会自动生成对应的ID保存在.R文件，我们调用这个ID就可以，但是只有这个ID还不够，.R文件只是保证编译程序不报错，实际上在程序运行时，系统要根据ID去寻找对应的资源路径，而resources.arsc文件就是用来记录这些ID和资源文件位置对应关系的文件。\n\n--->resouces.arsc映射逻辑https://juejin.im/post/6844903911602683918\n\n索引是指在R.java文件中生的资源ID：\n\n```java\npublic final class R{\n\tpublic static final class drawable { \n    \tpublic static final int icon=0x7f020000;\n    }\n}\n```\n\n格式为：0xPPTTEEEE。\n\nesouces.arsc文件结构分为几大类:\n\n- RES_TABLE_TYPE(描述的是整个resources.arsc的属性)\n\n- RES_STRING_POOL_TYPE（字符串资源池，主要存储**字符串**，注意这里的字符串资源池不包括资源类型和资源名）\n\n- RES_TABLE_PACKAGE_TYPE（是一个包的概念，主要记录**资源类型**偏移和**包名**偏移，**索引串0xPPTTEEEE中的PP的值**一般为7f）\n\n- RES_TABLE_TYPE_SPEC_TYPE（代表资源类型，Android中资源有attr,drawable,layout等，每一个类型都有这样的一个结构，所以在块中有多个，每个资源类型结构后面会跟着包名的数组，如drawable类型有多个尺寸的，所以有多少种尺寸后面就会跟着多少个RES_TABLE_TYPE_TYPE块，**索引串0xPPTTEEEE中的TT的值**）\n\n- RES_TABLE_TYPE_TYPE （每一个RES_TABLE_TYPE_TYPE里面包含一个ResTable_entry的数组，每一个资源的具体内容；注意上图中有一个ResTable_entry的偏移数组，这个**数组就是0xPPTTEEEE中的EEEE**；资源分bag和非bag类型，bag类型是值是确定的，非bag类型的值是有多个的）\n\n  \n\n## Android四大组件\n\n\n\n### 一.Activity\n\n![Activity](E:\\blog图片\\Activity.jpg)\n\n#### 1.1生命周期\n\n![生命周期](E:\\blog图片\\生命周期.jpg)\n\n#### 1.2Activity的创建流程\n\n1. 自定义Activity类名，继承Activity类或者它的子类\n2. 重写onCreate（）方法，在该方法中调用setContentView（）设置要显示的视图\n3. 再AndroidManifest.xml对Activity进行配置\n4. 启动Activity\n5. 关闭activity\n\n1.3activity数据状态保存onSaveInstanceState\n\n一个参数：\n\n```java\n@override\npublic void onCreate (Bundle savedInstantanceState){\n\tsuper.onCreate(saveInstanceState);\n\tsetContentView(R.layout.activity_main);\n}\n```\n\n一般情况下，只有一个参数，页面数据短暂保存，返回或暂时离开或者横竖屏切换时调用onSaveInstanceState(Bundle outState)，再返回调用onRestoreInstanceState(Bundle saveInstanceState)\n\n两个参数\n\n```\n@override\npublic void onCreate (Bundle saveInstanceState,PersistableBundle persistentState){\n\tsuper.onCreate(saveInstanceState,persistentState);\n}\n```\n\nPersistableBundle参数来自配置文件中我们设置的Activity设置的一个属性：\n\n```\nandroid:persistableMode=“persistAcrossReboots（重启设备，会持久化页面的数据或者状态）|persistRootOnly|persistNever\"\n```\n\n这样Activity拥有了持久化的能力，系统关机后重启的数据恢复能力。\n\n### ContentProvider\n\n一个应用的数据允许被另一个应用读取操作，可以通过ContentProvider类来实现，同时注册一个uri，使用ContentProvide根据uri就可以操作app中的数据\n\n## 利用contentprovider读取短信联系人\n\nMainActivity.java\n\n```\npackage com.example.sms;\n\nimport androidx.appcompat.app.AppCompatActivity;\n\nimport android.content.ContentResolver;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.widget.ListView;\n\npublic class MainActivity extends AppCompatActivity {\n\n    private ListView listView;\n    private ContentResolver cr;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        getMsgs();\n    }\n\n    private void getMsgs() {\n        Uri uri = Uri.parse(\"content://sms/\");\n        ContentResolver resolver = getContentResolver();\n        //获取的是哪些列的信息\n        Cursor cursor = resolver.query(uri, new String[]{\"address\",\"date\",\"type\",\"body\"}, null, null, null);\n        while(cursor.moveToNext())\n        {\n            String address = cursor.getString(0);\n            String date = cursor.getString(1);\n            String type = cursor.getString(2);\n            String body = cursor.getString(3);\n            System.out.println(\"地址:\" + address);\n            System.out.println(\"时间:\" + date);\n            System.out.println(\"类型:\" + type);\n            System.out.println(\"内容:\" + body);\n            System.out.println(\"======================\");\n        }\n        cursor.close();\n    }\n}\n```\n\nAndroidMainfest.xml\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.sms\">\n    <uses-permission android:name=\"android.permission.READ_SMS\"/>\n    //获取权限\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Sms\">\n        <activity android:name=\".MainActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n\n</manifest>\n```\n\n问题：运行时，发现不能获取权限。"},{"url":"/2021/01/29/BroacastReceive优先级与ReceiveList/","content":"# BroacastReceive优先级与ReceiveList\n\n### 系统广播接收优先级\n\n- 动态注册优先级别最高，其次静态注册\n- 在动态注册中，最早动态注册优先级别最高\n- 在静态注册中，最早安装的程序，静态注册优先级别最高（注：安装APK会解析manifest.xml,把其加入队列）\n- 都是静态注册的情况下，按照字符排列顺序决定谁先收到广播消息\n- adb install xxx.apk安装的应用优先级比adb push到其他目录的应用高\n- 总体来说：对于接收同一个广播，在相同优先级的情况下，动态注册优先级别高于静态注册。在动态注册中，最早动态注册优先级别最高；在静态注册中，最早安装的程序，静态注册优先级别最高（安装APK会解析manifest.xml,把其加入队列）\n\n参考链接：https://ruanyandong.github.io/2018/10/23/Android%E5%B9%BF%E6%92%AD%E7%9A%84%E9%A1%BA%E5%BA%8F/\n\n### 获取广播的所有接收者\n\n注册BroadcastReceiver的过程是这样的：Activity调用registerReceiver，然后经过几层内部类接口的调用之后，通过Binder机制与ActivityManagerService通信，而ActivityManagerService里有一个ReceiverList保存着系统所有的BroadcastReceiver。\n\n发送广播的过程是：Activity向ActivityManagerService发送广播，ActivityManagerService查找ReceiverList，通过比对IntentFilter找到所有对应的BroadcastReceiver，根据BroadcastReceiver的优先级进行排序后，扔进广播发送队列里。而后由专门的线程负责投递广播消息。\n\n获取ReceiverList就可以查看到获取系统BroadcastReceiver的列表，根据查看框架源码发ReceiverList是按照**优先级顺序**排序，这样可以通过ReceiverList来查看注册指定动作的广播优先级。\n\nframeworks\\base\\services\\java\\com\\android\\server\\IntentReslover.java，通过debug选项可以打印出最终获得的ReceiverList\n\n```java\npublic List<R> queryIntent(Intent intent, String resolvedType, boolean defaultOnly) {\n        String scheme = intent.getScheme();\n \n        ArrayList<R> finalList = new ArrayList<R>();\n \n        final boolean debug = localLOGV ||\n                ((intent.getFlags() & Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0);\n \n        if (debug) Slog.v(\n            TAG, \"Resolving type \" + resolvedType + \" scheme \" + scheme\n            + \" of intent \" + intent);\n       sortResults(finalList);//排序\n       \n        if (debug) {\n            Slog.v(TAG, \"Final result list:\");\n            for (R r : finalList) {\n                Slog.v(TAG, \"  \" + r);//打印ReceiverList\n            }\n        }\n        return finalList;\n    }\n```\n\n编写demo可以得到ReceiverList\n\n```java\n\nIntent intent = new Intent(\"com.android.deskclock.ALARM_ALERT\");\nintent.addFlags(Intent.FLAG_DEBUG_LOG_RESOLUTION);\nsendBroadcast(intent);\n```\n\n打开应用顺序：火山→超强→84\n\n锁屏顺序：84→超强→火山\n\nReceiverList显示结果：\n\n![image2021-1-15_16-23-50](E:\\blog图片\\image2021-1-15_16-23-50.png)\n\n同时我在发出广播时遇到了一个问题，系统受保护广播例如android.intent.action.SCREEN_ON，是不可以由外部应用发出，只能由系统才能发出。\n\n参考链接：获取广播接收者https://bbs.pediy.com/thread-156436.htm\n\nandroid受限广播机制https://my.oschina.net/easley/blog/270296\n\n"},{"url":"/2021/01/29/12.04学习/","content":"# 12.04学习\n\n```\nfinal IntentFilter filter = new IntentFilter();     \n*// 屏幕灭屏广播*      \nfilter.addAction(Intent.ACTION_SCREEN_OFF);      \n*// 屏幕亮屏广播*      \nfilter.addAction(Intent.ACTION_SCREEN_ON);      \n*// 屏幕解锁广播*      \nfilter.addAction(Intent.ACTION_USER_PRESENT);      \n*// 当长按电源键弹出“关机”对话或者锁屏时系统会发出这个广播*      \n*// example：有时候会用到系统对话框，权限可能很高，会覆盖在锁屏界面或者“关机”对话框之上，*      *// 所以监听这个广播，当收到时就隐藏自己的对话，如点击pad右下角部分弹出的对话框*       \nfilter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);  \n```\n\n`adb shell dumpsys activity | findstr \"mResume\"`查看当前activity\n\n## Uri.parse()的各种用法\n\n参考链接https://blog.csdn.net/qq_36497605/article/details/54907733"},{"url":"/2021/01/29/12.09学习/","content":"## 12.09-12.10学习 Android自定义锁屏\n\n分析锁屏广告的时候让我研究一下怎样让锁屏activity置于系统锁屏之上的，由此而来一篇学习\n\n写在前面\n\n#### Android 的API 27FLAG_SHOW_WHEN_LOCKED已经弃用\n\n正常Android自定义锁屏都会用到FLAG_SHOW_WHEN_LOCKED这个flag，但是从API 27之后由于Android的安全性考虑FLAG_TURN_SCREEN_ON和FLAG_SHOW_WHEN_LOCKED都已经被弃用 ，改为用\n\n```\n//指定Activity在每次锁定屏幕并恢复活动时是否应在锁定屏幕顶部显示\nsetShowWhenLocked(true)\n//点亮屏幕\nsetTurnScreenOn(true) \n```\n\n和keyguardManager.requestDismissKeyguard解锁屏幕（必需）\n\n官方文档解释https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#FLAG_SHOW_WHEN_LOCKED\n\n由于网上的教程都是关于之前的版本的，所以分析还是会以FLAG_SHOW_WHEN_LOCKED为主。\n\n言归正传，讲一讲Android自定义锁屏整个流程，当然整个流程是以Android逆向中锁屏广告的分析来看的，所以特别涉及开发的部分是会省略掉的\n\n### 基本原理\n\n思路：APP监听系统SCREEN_OFF和SCREEN_ON广播，当屏幕熄灭时，service监听到广播开启一个锁屏页Activity在屏幕最上层显示，当没有密码时直接去掉系统锁屏。\n\n![image-20201210151443824](E:\\blog图片\\image-20201210151443824.png)\n\n#### 广播注册\n\n监听熄屏，开屏，解锁系统广播\n\n```java\nIntentFilter mScreenOffFilter = new IntentFilter();\n mScreenOffFilter.addAction(Intent.ACTION_SCREEN_OFF);\n registerReceiver(mScreenOffReceiver, mScreenOffFilter);  \n 　　对应的BroadcastReceiver定义如下：\n\n private BroadcastReceiver mScreenOffReceiver = new BroadcastReceiver() {\n     @SuppressWarnings(\"deprecation\")\n     @Override\n     public void onReceive(Context context, Intent intent) {\n         if (intent.getAction().equals(NOTIFY_SCREEN_OFF)) {\n             Intent mLockIntent = new Intent(context, LockScreenActivity.class);\n             mLockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK\n                     | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);\n             startActivity(mLockIntent);\n         }\n     }\n };\n```\n\n关于启动Activity时Intent的Flag问题，如果不添加FLAG_ACTIVITY_NEW_TASK的标志位，会出现“Calling startActivity() from outside of an Activity”的运行时异常，毕竟我们是从Service启动的Activity。Activity要存在于activity的栈中，而Service在启动activity时必然不存在一个activity的栈，所以要新起一个栈，并装入启动的activity。使用该标志位时，也需要在AndroidManifest中声明taskAffinity，即新task的名称，否则锁屏Activity实质上还是在建立在原来App的task栈中。\n\n标志位FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS，是为了避免在最近使用程序列表出现Service所启动的Activity,但这个标志位不是必须的，其使用依情况而定。\n\n**屏幕相关广播**\n\n```java\n//屏幕亮起\nandroid.intent.action.SCREEN_ON\n//解锁屏幕\nandroid.intent.action.USER_PRESENT\n//屏幕熄灭\nandroid.intent.action.SCREEN_OFF\n```\n\n#### Acivity设置\n\n锁屏的activity做相应的配置，让activity在锁屏时也能够显示，同时去掉系统锁屏。但基于现在一般手机都有密码，而且之前去掉系统锁屏的方法也已经不适用换成keyguardManager.requestDismissKeyguard（），所以这里不具体讲去掉锁屏的过程。\n\n这里贴一个检查Android锁屏状态/锁屏密码相关的代码\n\n```java\n//当前系统锁屏是否有密码\npublic boolean hasScreenLockPwd(Context mContext){\n\tKeyguardManager keyguardManager = (KeyguardManager )mContext.getSystemService(Context.KEYGUARD_SERVICE);\n\treturn keyguardManager.isKeyguardSecure();\n}\n\n\n//当前系统是否处于锁屏状态\npublic boolean hasScreenLocked(Context mContext){\n\tKeyguardManager keyguardManager = (KeyguardManager )mContext.getSystemService(Context.KEYGUARD_SERVICE);\n\treturn keyguardManager.isKeyguardLocked();\n}\n```\n\n**锁屏activity实现**\n\n我们在自定义锁屏Activity的OnCreate()方法里设定一下标志位就能实现将锁屏activity置于锁屏界面之上\n\n```java\n//使得窗口浮在锁屏界面之上\ngetWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);\n```\n\n#### 按键屏蔽\n\n只有通过过划瓶或者指纹才能解锁，因此有必要对按键进行一定程度上的屏蔽。\n\nBack键和Menu键可以通过重写onKeyDown()方法进行屏蔽：\n\n```java\n public boolean onKeyDown(int keyCode, KeyEvent event) {\n     int key = event.getKeyCode();\n     switch (key) {\n         case KeyEvent.KEYCODE_BACK: {\n             return true;\n         }\n         case KeyEvent.KEYCODE_MENU:{\n             return true;\n         }\n     }\n     return super.onKeyDown(keyCode, event);\n }\n```\n\n#### 划屏解锁\n\n手指在屏幕上滑动时，拦截并处理滑动事件，使锁屏页面随着手指运动，当运动到达一定的阀值时，用户手指松开手指，锁屏页自动滑动到屏幕边界消失，如果没有达到运动阀值，就会自动滑动到起始位置，重新覆盖屏幕。\n\n为了将划屏逻辑与页面内容隔离开来，我们在锁屏页面布局中添加一个自定义的UnderView，这个UnderView填充整个屏幕，位于锁屏内容View（将其引用称之为mMoveView,并传入到UnderView中）的下方，所有划屏相关的事件都在这里拦截并处理。\n\nmMoveView是锁屏页的显示内容，除了处理一些简单的点击事件，其他非点击事件序列都由底层的UnderView进行处理。只需要重写UnderView的onTouchEvent方法就能够实现\n\n此外，我们可以通过getBackground()获取UnderView的背景，并根据已划开屏幕占整个屏幕的百分比调用setAlpha方法改变背景的透明度，做出抽屉拉开时的光影变化效果。\n\n具体代码参考链接，此处只讲思路，不多赘述。\n\n\n\n注意请求小米的锁屏activity时要加入小米白名单，同时在了解锁屏广告时还发现OP_SHOW_WHEN_LOCKED这个标识符，了解知道这个是锁屏上显示权限的标识，值为10020，作用是检测应用是否具备锁屏上显示权限，具体参考https://patents.google.com/patent/WO2018049609A1/zh\n\n\n\n参考链接：https://zhuanlan.zhihu.com/p/21628574\n\n​\t\t\t\t\thttps://stackoverflow.com/questions/48277302/android-o-flag-show-when-locked-is-deprecated\n\n​\t\t\t\t\thttps://stackoverflow.com/questions/40611432/getwindow-addflags-in-android\n\n​\t\t\t\t\thttps://www.cnblogs.com/zhou-guobao/p/4994762.html\n\n​\t\t\t\t\thttps://www.jianshu.com/p/36916ce0ab3b\n\n​\t\t\t\t\thttps://juejin.cn/post/6844903841377288199"},{"url":"/2021/01/29/frida安装以及脱壳/","content":"# frida安装以及脱壳\n\n### frida的安装\n\n公司网络无法使用pip的官方源，将官方源换成清华源\n\n`pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple`\n\npip安装frida\n\n`pip install frida`\n\n安装frida-tools\n\n`pip install frida-tools`\n\n### 手机中安装frida服务端\n\n查看Android手机设备\n\n`getprop ro.product.cpu.abi`\n\n根据cpu版本去https://github.com/frida/frida/releases下载相应frida-server,手机是arm64-v8a的，找到相应的服务器server\n\n![image-20201119110940552](E:\\blog图片\\image-20201119110940552.png)\n\n下载后将解压的文件push进手机\n\n`adb push frida-server-14.0.8-android-arm64 /data/local/tmp`\n\n查看文件权限\n\n`ls -l`\n\n给Frida问件加权限\n\n`chmod 777 frida-server-14.0.8-android-arm64`\n\n运行文件\n\n![image-20201119111940258](E:\\blog图片\\image-20201119111940258.png)\n\n再打开个cmd窗口，输入命令frida-ps -U\n\n![image-20201119112209545](E:\\blog图片\\image-20201119112209545.png)\n\n### 脱壳工具的使用\n\n工具来源https://github.com/hluwa/FRIDA-DEXDump\n\n从pip安装frida-dexdump\n\n`pip3 install frida-dexdump`\n\n查看是否安装成功\n\n`frida-dexdump -h`\n\n出现如下页面安装成功\n\n![image-20201119105602502](E:\\blog图片\\image-20201119105602502.png)\n\n使用参数\n\n```\n-n: [Optional] Specify target process name, when spawn mode, it requires an application package name. If not specified, use frontmost application.\n-p: [Optional] Specify pid when multiprocess. If not specified, dump all.\n-f: [Optional] Use spawn mode, default is disable.\n-s: [Optional] When spawn mode, start dump work after sleep few seconds. default is 10s.\n-d: [Optional] Enable deep search maybe detected more dex, but speed will be slower.\n-h: show help.\n```\n\n脱壳命令\n\n`frida-dexdump -n 包名`\n\n![image-20201119112705032](E:\\blog图片\\image-20201119112705032.png)\n\n默认保存在用户文件夹下\n\n![image-20201119112815476](E:\\blog图片\\image-20201119112815476.png)\n\n"},{"url":"/2021/01/29/11.30学习/","content":"# 11.30学习\n\n## SharedPreferences类\n\n在一款软件自动生成平台生成的勒索软件上见到这个类\n\nAndroid平台给我们提供了一个SharedPreferences类，它是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件存放在/data/data/<package name>/shared_prefs目录下。此类功能类似于初始化配置参数的存储。\n\n具体参见https://www.cnblogs.com/linjiqin/archive/2011/05/26/2059133.html\n\n## NotificationListenerService\n\n在一款钓鱼软件上见到此服务\n\n使用NotificationListenerService主要目的是为了获取系统通知相关信息，主要包括：通知的新增和删除，获取当前通知数量，通知内容相关信息等。这些信息可以通过NotificationListenerService类提供的方法以及 StatusBarNotification类对象来获取\n\nNotificationListenerService中还有一些方法可供我们使用，下面是一些经常使用的方法：\n\n> cancelAllNotifications(); *//移除所有可移除的通知*\n> cancelNotification(String key); *//移除指定key的通知，要求api21以上*\n> cancelNotifications(String[] keys); *//移除指定数组内的所有key的通知，要求api21以上*\n> getActiveNotifications()； *//获取通知栏上的所有通知，返回一个StatusBarNotification[]*\n> onNotificationPosted(StatusBarNotification sbn);*//当系统收到新的通知后出发回调；*\n> onNotificationRemoved(StatusBarNotification sbn); *//当系统通知被删掉后出发回调；*\n\n通过这些方法就可以在应用中操作系统通知，在 NotificationListenerService中除了对通知的操作之外，还可以获取到通知的StatusBarNotification对象， 通过该对象可以获取通知更详细的数据。\n\n详见https://zhuanlan.zhihu.com/p/62380569"},{"url":"/2021/01/29/12.07学习/","content":"# Android启动模式和TaskAffinity\n\n## 任务和返回栈\n\n应用通常包含多个 Activity ，每个 Activity 均应围绕用户可以执行的特定操作设计，并且能够启动其他 Activity，一个 Activity 可以启动设备上其他应用中的 Activity，即使两个 Activity 可能来自不同的应用，但是 Android 仍会将 Activity 保留在相同的任务中，以维护这种无缝的用户体验。这里所说的**任务**就是指在执行特定作业时与用户交互的一系列 Activity，这些 Activity 按照各自的打开顺序排列在**堆栈**（即返回栈）中。**返回栈**以“后进先出”对象结构运行。\n\n查看activity Task栈的情况 adb命令：\n\nadb shell dumpsys activity activities\n\n## 启动模式\n\n一直启动activity系统会创建多个实例，提供提供启动模式来修改系统的默认行为\n\n```java\nadnroid:launchMode=\"standard\" or \"1\"\n\n\t\t\t\t\t\"singleTop\" or \"2\"\n\n\t\t\t\t\t\"singleTask\" or \"3\"\n\n\t\t\t\t\t\"singleInstance\" or \"4\"\n```\n\n## standard默认模式\n\n系统每启动一次 Activity 的任务就会创建一次 Activity 的新实例并向其传送 Intent。每个实例可以属于不同的任务，一个任务也能拥有多个实例。这种模式的 Activity 被创建时它的 onCreate、onStart 都会被调用。\n\n## singleTop栈顶复用模式\n\n如果当前任务的顶部已存在Activity的一个实例，则系统会通过调用该实例onNewIntent()方法向其传送Intent，而不是创建Activity的新实例。当返回栈顶部不是所需Activity的现有实例，Activity可以被多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。这个 Activity 的 onCreate、onStart 不会被系统调用，因为它并没有发生改变。\n\n## singleTask 栈内复用模式\n\n单例模式下，只要Acivity在一个栈中存在，那么多次启动次Activity都不会创建新实例，但是会通过回调onNewIntent来启动。\n\n当具有一个singleTask模式的Activity请求启动后，比如Activity A,系统会先寻找是否存在A**想要的任务栈**（**taskAffinity属性**），如果不存在，就重新创建一个任务栈，然后创建 A 的实例后把 A 放到栈中。如果存在 A 所需的任务栈，这时要看 A 是否在栈中有实例存在，如果有实例存在，那么系统就会把 A 调到栈顶并调用它的 onNewIntent 方法，如果实例不存在，就创建 A 的实例并把 A 压入栈中 。\n\n关于上文中所说的`想要的任务栈`，指的是 taskAffinity 属性。\n\nsingleTask 默认有 clearTop 的效果，会导致栈内所有在它上面的 Activity 全部出栈\n\nsingleInstance单实例模式\n\n与 singleTask 相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。该 Activity 始终是其任务唯一仅有的成员；由此 Activity 启动的任何 Activity 均在单独的任务中打开。也就是有此种模式的 Activity 只能单独地位于一个任务栈中\n\n如果已经创建过，则调用 onNewIntent 方法 不会调用 onCreate 和 onStart\n\n## taskAffinity属性\n\ntaskAffinity 属性主要和 singleTask 或者 allowTaskReparenting 属性配对使用，在其他情况下没有意义。\n\n当设置了taskAffinity属性那么这个 Activity 在被创建时就会运行在和 taskAffinity 名字相同的任务栈中，如果没有，则新建 taskAffinity 指定的任务栈，并将 Activity 放入该栈中。\n\n![image-20201208161046801](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201208161046801.png)\n\n## 总结\n\n|   launchMode   |                         使用场景                          |\n| :------------: | :-------------------------------------------------------: |\n| **singleTop**  | 适合启动同类型的 Activity，例如接收通知启动的内容显示页面 |\n|   singleTask   |                     适合作为程序入口                      |\n| singleInstance |      适合需要与程序分离开的页面，例如闹铃的响铃界面       |\n\nonNewIntent()方法\n\n当Acivity已经被启动且处于当前应用返回栈中，activity的**LaunchMode**为SingleTop、SingleTask、SingleInstance时会被调用。\n\n- 当Acivityde LaunchMode为singleTop时\n\n  当需要再次响应次Activity启动需求时，会复用栈顶的已有的Activity,还会调用onNewIntent（）方法，并且，再次接受新发来的intent()一定会先执行onPause()方法。\n\n  生命周期顺序：onCreate->onStart->onResume->**onPause**->**onNewIntent**->**onResume**\n\n- 当Activity的LaunchMode为SingleTask，SingleInstance\n\n  生命周期调用顺序：onCreate -> onStart -> onResume -> …… -> onPause -> **onStop** -> **onNewIntent** -> **onRestart** -> onStart -> onResume\n\n\n\n**onNewIntent()中的陷阱：**\n\n当多次启动一个栈唯一模式下的activity时，在onNewIntent()里面的getIntent()得到的intent感觉都是第一次的那个数据。\n\n在**这儿会有个陷阱**，因为它就是**会返回第一个intent的数据**，就是这个坑。\n\n原因是因为**没有**在`onNewIntent()`里面设置`setIntent()`，即将**最新**的**`intent`**设置在**这个activity实例**中。\n\n```\n@Override\nprotected void onNewIntent(Intent intent) {\n    super.onNewIntent(intent);\n    setIntent(intent);//设置新的intent\n    int data = getIntent().getIntExtra(\"tanksu\", 0);//此时的到的数据就是正确的了\n}\n```\n\n\n\n参考链接：https://www.cnblogs.com/pshell/p/7979649.html\n\nhttps://www.jianshu.com/p/2c73be80ce8d\n\nhttps://blog.csdn.net/goodlixueyong/article/details/49620667\n\nhttps://juejin.cn/post/6844904007085850631\n\n"},{"url":"/2021/01/29/记录一次nexus6p的刷机过程/","content":"记录一次nexus6p的刷机过程\n\n刷机准备\n\n打开手机oem锁和开发者模式\n\nadb工具\n\nAndroid8.1.0镜像https://developers.google.com/android/ota 寻找手机对应版本镜像如Nexus 6P，并找到对应版本。\n\n解锁BootLoader\n\n手机关机后，长按音量-和电源键\n\n检查链接设备\n\nfastboot devices\n\n解锁\n\nfastboot oem unlock\n\n刷机"},{"url":"/2021/01/29/01.25学习/","content":"# 保活\n\n保活方法有以下几种：\n\n1.长连接和心跳保活\n\n2.JobSheduler进程重生\n\n3.一像素进程保活\n\n4.双进程保活\n\n5.腾讯终极永生术(Native拉活)\n\n其中[史上最强Android保活思路：深入剖析腾讯TIM的进程永生技术](https://segmentfault.com/a/1190000021579231)这篇文章有较完全的保活技术文章总结\n\n## 一.心跳保活\n\n心跳保活的实现要完成三点：1.建立长连接2.固定时间发送心跳包3.服务端超时后要重连\n\n### 长连接介绍\n\n通信双方进行TCP链接后进行通信，结束后不主动关闭链接 优点：通信速度快，免去了DNS解析时间，以及三次握手四次分手的时间，避免短时间内重复连接所造成的信道资源 & 网络资源的浪费\n\n### 心跳的实现\n\n![20180419152127961](E:\\blog图片\\20180419152127961.png)\n\n- 连接后主动到服务器Sync拉取一次数据，确保连接过程的新消息。\n- 心跳周期的Alarm唤醒后，一般有几秒的cpu时间，无需wakelock。\n- 心跳后的Alarm是为了防止发送超时，如服务器正常会包，该Alarm取消。\n- 如果心跳后发送超时了，那么要和服务器重新建立连接拉取数据\n- 如果服务器回包，系统通过网络唤醒，无需wakelock。\n\n流程基于两个系统特性：\n\n- Alarm唤醒后，足够cpu时间发包。\n- 网络回包可唤醒机器\n\n### 动态心跳\n\n动态心跳引入下列状态：\n\n- 前台活跃态：亮屏，微信在前台，周期为minHeart(4.5min),保证体验\n- 后台活跃态：微信在后台10分钟内，周期为minHeart（4.5min），保证体验\n- 自适应计算态：步增心跳，尝试获取最大心跳周期（sucHeart）\n- 后台稳定态：通过最大周期，保持稳定心跳\n\n自适应计算态流程：\n![这里写图片描述](https://img-blog.csdn.net/2018041917384831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEzMzc1NzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n在自适应态：\n\n- curHeart初始值为minHeart，步增（heartStep）为1分钟\n- curHeart失败5次，意味着整个自适应态最多只有5分钟无法接受消息\n- 结束后，如果sucHeart > minHeart，会减去10s（避开临界），为该网络下的稳定周期\n\n稳定态的退出：\nsucHeart会对应网络存储下来，重启后正常使用。考虑到网络的不稳定，如NAT超时变小，用户地理位置变换。当发现sucHeart连续失败5次，sucHeart置为minHeart，重新进入自适应状态。\n\n参考链接：\n\n[android网络连接保活](https://blog.csdn.net/u011337574/article/details/80007269) \n\n[谈谈长连接和心跳保活机制](https://cloud.tencent.com/developer/article/1637168)\n\n[正确理解IM长连接的心跳及重连机制，并动手实现（有完整IM源码）](https://www.cnblogs.com/imstudy/p/11718450.html)\n\n## 二.JobSheduler进程重生\n\nJobScheduler 简单来说就是一个系统定时任务，在app达到一定条件时可以指定执行任务，且如果app被强迫终止，此前预定的任务还可执行。\n\nJobScheduler是用于计划基于应用进程的多种类型任务的api接口。当任务执行时，系统会为应用持有WakeLock，所以应用不需要做多余的确保设备唤醒的工作。\n\nJobService继承自Service，是用于处理JobScheduler中规划的异步请求的特殊Service\n\nJobSheduler进程重生关注重点就是系统服务获取：\n\n`var mJobScheduler = ctxt.getSystemService(Context.JOB_SCHEDULER_SERVICE) as JobScheduler`\n\n参考链接：\n\n [JobScheduler进程保活](https://blog.csdn.net/shh152/article/details/99634927)\n\n[Android 进程保活（五）JobSheduler进程重生](http://www.zydeveloper.com/2019/07/16/processlive5/)\n\n## 三.一像素进程保活\n\n1像素保活方案就是我们在手机锁屏时开启一个Activity，为了不让用户有感知，让这个Activity大小为1像素并设置透明无切换动画。在开启屏幕时把这个Activity关掉。\n\n原理：主要是通过提高oom_adj的优先级可以使我们的app被系统杀死的概率变低。\n\n实现一像素保活要完成：1.设置一像素Activity 2.注册监听锁屏开启、关闭广播接收器来完成控制一像素Activity开启和关闭\n\n创建一像素Activity\n\n```java\npackage com.baweigame.mvvmdemoapplication;\n\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.Gravity;\nimport android.view.Window;\nimport android.view.WindowManager;\n\npublic class OnePXActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_one_px);\n\n        Log.d(\"123\", \"onCreate: OnePxActivity...\");\n        createOnePxWindow();\n\n        OnePxManager.getInstance().setActivity(this);\n    }\n\n    /**\n     * 创建1像素窗体\n     */\n    private void createOnePxWindow() {\n        Window window = getWindow();\n        //放在左上角\n        window.setGravity(Gravity.START | Gravity.TOP);\n        WindowManager.LayoutParams attributes = window.getAttributes();\n        //宽高为1个像素\n        attributes.width = 1;\n        attributes.height = 1;\n        \n        attributes.x = 0;\n        attributes.y = 0;\n        window.setAttributes(attributes);\n    }\n}\n```\n\n参考链接：\n\n[Android 进程保活（三）1像素方案保活](http://www.zydeveloper.com/2019/07/15/processlive3/)\n\n## 四.双进程保活\n\n双进程守护的思想就是，两个进程共同运行，如果有其中一个进程被杀，那么另一个进程就会将被杀的进程重新拉起，相互保护，在一定的意义上，维持进程的不断运行。\n\n双进程守护的两个进程，一个进程用于我们所需的后台操作，且叫它本地进程，另一个进程只负责监听着本地进程的状态，在本地进程被杀的时候拉起，于此同时本地进程也在监听着这个进程，准备在它被杀时拉起，我们将这个进程称为远端进程。\n\n由于在 Android 中，两个进程之间无法直接交互，所以我们这里还要用到 AIDL （Android interface definition Language ），进行两个进程间的交互。\n\n参考链接：\n\n[Android 双进程守护](https://www.jianshu.com/p/83ea5e03bd61)\n\n## 五.Native拉活\n\n原理：简单来说，两个线程建立文件锁，并fork出两个子线程，子线程也相互建立文件锁，当一个线程被杀死，另一个线程的子线程立马拉活被杀死的线程\n\n### **保活的底层技术原理**\n\n一般来说，系统杀进程有两种方法，这两个方法都通过 ActivityManagerService 提供：\n\n1. killBackgroundProcesses\n2. forceStopPackage\n\n在原生系统上，很多时候杀进程是通过第一种方式，除非用户主动在 App 的设置界面点击「强制停止」。不过国内各厂商以及一加三星等 ROM 现在一般使用第二种方法。第一种方法太过温柔，根本治不住想要搞事情的应用。第二种方法就比较强力了，一般来说被 force-stop 之后，App 就只能乖乖等死了。\n\n因此，要实现保活，我们就得知道 force-stop 到底是如何运作的。既然如此，我们就跟踪一下系统的 `forceStopPackage` 这个方法的执行流程：\n\n```java\npublic void forceStopPackage(final String packageName, int userId) {\n\n    // .. 权限检查，省略\n\n    long callingId = Binder.clearCallingIdentity();\n    try {\n        IPackageManager pm = AppGlobals.getPackageManager();\n        synchronized(this) {\n            int[] users = userId == UserHandle.USER_ALL\n                    ? mUserController.getUsers() : new int[] { userId };\n            for (int user : users) {\n\n                // 状态判断，省略..\n\n                int pkgUid = -1;\n                try {\n                    pkgUid = pm.getPackageUid(packageName, MATCH_DEBUG_TRIAGED_MISSING,\n                            user);\n                } catch (RemoteException e) {\n                }\n                if (pkgUid == -1) {\n                    Slog.w(TAG, \"Invalid packageName: \" + packageName);\n                    continue;\n                }\n                try {\n                    pm.setPackageStoppedState(packageName, true, user);\n                } catch (RemoteException e) {\n                } catch (IllegalArgumentException e) {\n                    Slog.w(TAG, \"Failed trying to unstop package \"\n                            + packageName + \": \" + e);\n                }\n                if (mUserController.isUserRunning(user, 0)) {\n                    // 根据 UID 和包名杀进程\n                    forceStopPackageLocked(packageName, pkgUid, \"from pid \" + callingPid);\n                    finishForceStopPackageLocked(packageName, pkgUid);\n                }\n            }\n        }\n    } finally {\n        Binder.restoreCallingIdentity(callingId);\n    }\n}\n```\n\n在这里我们可以知道，系统是通过 `uid` 为单位 force-stop 进程的，因此不论你是 native 进程还是 Java 进程，force-stop 都会将你统统杀死。我们继续跟踪`forceStopPackageLocked` 这个方法：\n\n```java\nfinal boolean forceStopPackageLocked(String packageName, int appId,\n        boolean callerWillRestart, boolean purgeCache, boolean doit,\n        boolean evenPersistent, boolean uninstalling, int userId, String reason) {\n    int i;\n\n    // .. 状态判断，省略\n\n    boolean didSomething = mProcessList.killPackageProcessesLocked(packageName, appId, userId,\n            ProcessList.INVALID_ADJ, callerWillRestart, true /* allowRestart */, doit,\n            evenPersistent, true /* setRemoved */,\n            packageName == null ? (\"stop user \" + userId) : (\"stop \" + packageName));\n\n    didSomething |=\n            mAtmInternal.onForceStopPackage(packageName, doit, evenPersistent, userId);\n\n    // 清理 service\n    // 清理 broadcastreceiver\n    // 清理 providers\n    // 清理其他\n\n    return didSomething;\n}\n```\n\n这个方法实现很清晰：先杀死这个 App 内部的所有进程，然后清理残留在 system_server 内的四大组件信息；我们关心进程是如何被杀死的，因此继续跟踪`killPackageProcessesLocked`，这个方法最终会调用到 `ProcessList` 内部的 `removeProcessLocked` 方法，`removeProcessLocked` 会调用 `ProcessRecord` 的 `kill` 方法，我们看看这个`kill`：\n\n```java\nvoid kill(String reason, boolean noisy) {\n    if (!killedByAm) {\n        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"kill\");\n        if (mService != null && (noisy || info.uid == mService.mCurOomAdjUid)) {\n            mService.reportUidInfoMessageLocked(TAG,\n                    \"Killing \" + toShortString() + \" (adj \" + setAdj + \"): \" + reason,\n                    info.uid);\n        }\n        if (pid > 0) {\n            EventLog.writeEvent(EventLogTags.AM_KILL, userId, pid, processName, setAdj, reason);\n            Process.killProcessQuiet(pid);\n            ProcessList.killProcessGroup(uid, pid);\n        } else {\n            pendingStart = false;\n        }\n        if (!mPersistent) {\n            killed = true;\n            killedByAm = true;\n        }\n        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n    }\n}\n\n```\n\n这里我们可以看到，首先杀掉了目标进程，然后会以`uid`为单位杀掉目标进程组。如果只杀掉目标进程，那么我们可以通过双进程守护的方式实现保活；关键就在于这个`killProcessGroup`，继续跟踪之后发现这是一个 native 方法，它的最终实现在 [libprocessgroup](https://link.zhihu.com/?target=http%3A//www.aospxref.com/android-10.0.0_r2/xref/system/core/libprocessgroup/processgroup.cpp%23390)中，代码如下：\n\n```\nint killProcessGroup(uid_t uid, int initialPid, int signal) {\n    return KillProcessGroup(uid, initialPid, signal, 40 /*retries*/);\n}\n```\n\n注意这里有个奇怪的数字：40。我们继续跟踪：\n\n```\nstatic int KillProcessGroup(uid_t uid, int initialPid, int signal, int retries) {\n\n    // 省略\n\n    int retry = retries;\n    int processes;\n    while ((processes = DoKillProcessGroupOnce(cgroup, uid, initialPid, signal)) > 0) {\n        LOG(VERBOSE) << \"Killed \" << processes << \" processes for processgroup \" << initialPid;\n        if (retry > 0) {\n            std::this_thread::sleep_for(5ms);\n            --retry;\n        } else {\n            break;\n        }\n    }\n\n    // 省略\n}\n```\n\n**循环 40 遍不停滴杀进程，每次杀完之后等 5ms**，循环完毕之后就算过去了。\n\n看到这段代码，我想任何人都会蹦出一个疑问：假设经历连续 40 次的杀进程之后，如果 App 还有进程存在，那不就侥幸逃脱了吗？\n\n### **实现方法**\n\n那么，如何实现这个目的呢？我们看这个关键的 **5ms**。假设，App 进程在被杀掉之后，能够以足够快的速度（5ms 内）启动一堆新的进程，那么系统在一次循环杀掉老的所有进程之后，sleep 5ms 之后又会遇到一堆新的进程；如此循环 40 次，只要我们每次都能够拉起新的进程，那我们的 App 就能逃过系统的追杀，实现永生。是的，炼狱般的 200ms，只要我们熬过 200ms 就能渡劫成功，得道飞升。不知道大家有没有玩过打地鼠这个游戏，整个过程非常类似，按下去一个又冒出一个，只要每次都能足够快地冒出来，我们就赢了。\n\n现在问题的关键就在于：**如何在 5ms 内启动一堆新的进程**？\n\n再回过头来看原来的保活方式，它们拉起进程最开始通过`am`命令，这个命令实际上是一个 java 程序，它会经历启动一个进程然后启动一个 ART 虚拟机，接着获取 ams 的 binder 代理，然后与 ams 进行 binder 同步通信。这个过程实在是太慢了，在这与死神赛跑的 5ms 里，它的速度的确是不敢恭维。\n\n后来，MarsDaemon 提出了一种新的方式，它用 binder 引用直接给 ams 发送 Parcel，这个过程相比 `am`命令快了很多，从而大大提高了成功率。其实这里还有改进的空间，毕竟这里还是在 Java 层调用，Java 语言在这种实时性要求极高的场合有一个非常令人诟病的特性：垃圾回收（GC）；虽然我们在这 5ms 内直接碰上 gc 引发停顿的可能性非常小，但是由于 GC 的存在，ART 中的 Java 代码存在非常多的 checkpoint；想象一下你现在是一个信使有重要军情要报告，但是在路上却碰到很多关隘，而且很可能被勒令暂时停止一下，这种情况是不可接受的。因此，最好的方法是通过 native code 给 ams 发送 binder 调用；当然，如果再底层一点，我们甚至可以通过 `ioctl` 直接给 binder 驱动发送数据进而完成调用，但是这种方法的兼容性比较差，没有用 native 方式省心。\n\n通过在 native 层给 ams 发送 binder 消息拉起进程，我们算是解决了「快速拉起进程」这个问题。但是这个还是不够。还是回到打地鼠这个游戏，假设你摁下一个地鼠，会冒起一个新的地鼠，那么你每次都能摁下去最后获取胜利的概率还是比较高的；但如果你每次摁下一个地鼠，其他所有地鼠都能冒出来呢？这个难度系数可是要高多了。如果我们的进程能够在**任意一个进程死亡之后，都能让把其他所有进程全部拉起**，这样系统就很难杀死我们了。\n\n新的黑科技保活中通过 2 个机制来保证进程之间的互相拉起：\n\n1. 2 个进程通过互相监听文件锁的方式，来感知彼此的死亡。\n2. 通过 fork 产生子进程，fork 的进程同属一个进程组，一个被杀之后会触发另外一个进程被杀，从而被文件锁感知。\n\n具体来说，创建 2 个进程 p1, p2，这两个进程通过文件锁互相关联，一个被杀之后拉起另外一个；同时 p1 经过 2 次 fork 产生孤儿进程 c1，p2 经过 2 次 fork 产生孤儿进程 c2，c1 和 c2 之间建立文件锁关联。这样假设 p1 被杀，那么 p2 会立马感知到，然后 p1 和 c1 同属一个进程组，p1 被杀会触发 c1 被杀，c1 死后 c2 立马感受到从而拉起 p1，因此这四个进程三三之间形成了铁三角，从而保证了存活率。\n\n参考链接：\n\n [Android黑科技保活实现原理揭秘](https://zhuanlan.zhihu.com/p/103126724)\n\n[史上最强Android保活思路：深入剖析腾讯TIM的进程永生技术](https://segmentfault.com/a/1190000021579231)"},{"url":"/2021/01/29/01.18学习/","content":"# 一些Android的API\n\n### Android DownLoadManager的使用\n\ngetSystemService(\"download\")\n\n https://blog.csdn.net/xiongzebao/article/details/51264291\n\n## WebView setDownloadListener() 下载文件\n\nhttps://www.twle.cn/l/yufei/android/android-basic-webview-download-file.html\n\nhttps://blog.csdn.net/qq_24867873/article/details/72910793\n\n### Android 安装应用的两种方式--外部应用安装器安装和静默安装(系统应用)\n\nhttps://blog.csdn.net/qqwuy_muzi/article/details/72961393\n\n### android.intent.action.CLOSE_SYSTEM_DIALOGS\n\nandroid.intent.action.CLOSE_SYSTEM_DIALOGS//当屏幕超时进行锁屏时,当用户按下电源按钮,长按或短按(不管有没跳出话框)，进行锁屏时,android系统都会广播此Action消息"},{"url":"/2021/01/29/01.04学习/","content":"# mitmproxy工具安装及使用\n\nmitmproxy是linux端的抓包工具，作用于MITM（Man-in-the-middle attack）的proxy。用于中间人攻击的代理首先会向正常的代理一样转发请求，保障服务端与客户端通信，其次，会适时的查，记录其截获的数据\n\n安装\n\nsudo pip install mitmproxy"},{"url":"/2021/01/29/01.13学习/","content":"# 01.13学习\n\nonPause()调用时机\n\n只有再启动另外一个Activity的时候才会进入onPause状态，而不是想象中的被覆盖或者不可见\n\n同时通过AlertDialog源码或者Toast源码我们都可以发现它们实现的原理都是windowmanager.addView();来添加的， 它们都是一个个view ,因此不会对activity的生命周期有任何影响。也就是调用自身的浮窗是不会调用onPause()\n\nObservable.interval定时执行分析https://blog.csdn.net/u013750244/article/details/105998679\n\nRxJava2 响应式编程介绍和背压问题https://zouzhberk.github.io/rxjava-study/\n\nRxJava创建interval操作符https://maxwell-nc.github.io/android/rxjava2-2.html#interval\n\n \n\n"},{"url":"/2021/01/29/01.29学习/","content":"# loadClass()\n\nClassLoader.loadClass(String name)能在运行时对任意一个类，都能够知道该类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性。\n\n与Class.forName(String name)不同的是，loadClass(\"\")得到的class是未链接，forName(\"\")得到的是初始化已经完成的，一般情况下，这两个方法效果一样，都能装载Class。 但如果程序依赖于Class是否被初始化，就必须用Class.forName(name)了。\n\n未链接是什么意思呢？这就需要了解Java类装载\n\njava类装载的过程分为三步：1. 加载 \n\n​                        \\2. 链接\n\n​                        \\3. 初始化\n\n1：加载\n\n　　Jvm把.class文件**字节码**加载到内存中，并将这些静态数据装换成运行时数据区中方法区的**类型数据**，在运行时数据区堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的**访问入口**。\n\n　　***\\*******释：\\****方法区不仅仅是存放方法，它存放的是类的**类型信息**。*\n\n2：链接：执行下面的**校验**、**准备**和**解析**步骤，其中解析步骤是可选的\n\n　　　　a：**校验**：检查加载的class文件的正确性和安全性\n\n　　　　b：**准备**：为类变量分配存储空间并设置类变量初始值，类变量随类型信息存放在方法区中,生命周期很长，使用不当和容易造成内存泄漏。\n\n　******释**：类变量就是**static**变量；初始值指的是类变量类型的默认值而不是实际要赋的值*\n\n　　　　c：**解析**：jvm将常量池内的符号引用转换为直接引用\n\n3：初始化：执行类变量赋值和静态代码块\n\n\n\n### 验证使用\n\n使用loadClass调用com.test.getme下的start方法\n\n```java\npackage cn.twle.android.testloadclass;\n\nimport androidx.appcompat.app.AppCompatActivity;\nimport android.os.Bundle;\nimport com.test.getme;\n\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        try {\n            get v = (get) getClassLoader().loadClass(\"com.test.getme\").newInstance();\n            v.start();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```java\npackage cn.twle.android.testloadclass;\n\npublic interface get {\n    public void start();\n}\n```\n\n```java\npackage com.test;\nimport cn.twle.android.testloadclass.get;\n\npublic class getme implements get {\n    public void start(){\n        System.out.println(\"getme!\");\n    }\n}\n```\n\n打印结果\n\n![QQ图片20210129173819](E:\\blog图片\\QQ图片20210129173819.png)\n\n"},{"url":"/2020/05/10/梆梆加固原理及脱壳/"},{"title":"android studio 3.5编译一个.so","url":"/2020/04/06/android studio 3.5编译一个so/","content":"\n# 简单介绍JNI和NDK #\nJNI：Java Native Interface,java本地接口，可以使Java与本地其他语言进行交互，如C语言，C++。\nNDK：Native Development Kit是Android的一个开发工具包，快速开C与C++的动态库，并自动将so文件和应用一起打包成APK\n# 简单快速方法 #\n\n先在setting下载好ndk，cmake，lldb，然后新建项目\n\n![](https://i.imgur.com/vuTGObh.png)\n\n选择native c++然后next，输入项目名称，一路next到finish。\n\n![](https://i.imgur.com/AOPoQgC.png)\n打开main文件夹下的cpp文件，可以看到已经写好的CMakeLists.txt和native-lib.cpp，native-lib.cpp文件，它是提供对外接口的，之后我们调用时就是通过一个java类调用这个c++文件中的接口的。\n\n打开main文件夹下的build.gradle,填写一些配置\n![](https://i.imgur.com/GVZtIUH.png)\n修改成：\n![](https://i.imgur.com/WVGT5HY.png)\nbuild一下就生成了.so文件，在app——>build——>intermediates——>cmake下生成对应的.so库\n\n使用此种方法.so文件声明调用都在MainActivity中，而且对外接口只有一个native-lib.cpp,不能使用多个.cpp文件实现功能。\n解决办法：第一种：参考完整版写一个Java文件用javah生成.h文件，完成c代码复制到之前的native-lib.cpp中，然后rebuild；第二种将得到的接口文件（.h文件）在cpp文件夹下新建一个.cpp文件将接口文件的代码复制进去，并在CMakeLists.txt中添加新.cpp文件的源文件地址，rebuild即可。\n\n# 完整版 #\n个人觉得这个版本复杂很多但是我们可以更完整的了解建立so库的全部过程，对于后面逆向的学习有更好的理解\n\n新建一个空项目，在Project Structure里面配置好NDK，不知道为什么在gradle3.5不能下载应用ndk之后自动配置，每一次要手动配置。\n![](https://i.imgur.com/NvsVJfd.png)\n![](https://i.imgur.com/woB6DhH.png)\n检查是否配置好在gradle这个文件夹下查看local.properties文件里面是否函数有ndk的地址。![](https://i.imgur.com/6Uuqts2.png)\n\n新建一个Testjni.java\n```JAVA\npublic class MyJni {\n\n    static {\n        System.loadLibrary(\"testjni\");\n    }\n\n    public native static String getString();\n}\n\n```\n点击build-->make project,生成.class文件\n\n找到classes文件夹，一般在E:\\Android\\TestJNI\\app\\build\\intermediates\\javac\\debug下，使用javah来生成.h文件，命令为``` javah -jni com_example_testjni_testjni ```,生成com_example_testjni_testjni.h\n\n在src/main/下创建jni目录将上述.h文件复制进去，并创建.c文件，并把下面代码复制进去\n```JAVA\n#include <jni.h>\n#include \"com_example_testjni_testjni.h\"\n#include <stdio.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nJNIEXPORT jstring JNICALL com_example_testjni_testjni_getString\n  (JNIEnv *env, jclass jz){\n\n  return (*env)->NewStringUTF(env,\"this is the first time for me to use jni\");\n\n  }\n#ifdef __cplusplus\n}\n#endif\n```\n再创建Android.mk和Application.mk文件（个人觉得这种太麻烦了，Cmake简单明了）\nAndroid.mk是一个向Android NDK构建系统描述NDK项目的GNU makefile片段。我的理解是链接文件，告诉ndk操作的一些信息\n**Android.mk**\n```\n#定义模块当前路径(必须定义在文件开头，只需定义一次)\nLOCAL_ PATH := $(call my-dir)\n#清空当前环境变量 (LOCAL_PATH除外)\ninclude $(CLEAR_VARS )\n#当前模块名(这里会生成libhello-jni.so),模块名唯一,且不能包含空格\nLOCAL_MODULE := testjni\n#当前模块包含的源代码文件\nLOCAL_ SRC_ FILES := test.c\n#表示当前模块将被编译成一个共享库\ninclude $(BUILD_ SHARED_LIBRARY)\n```\n**Application.mk**\n```\nAPP_ABI := armeabi armeabi-v7a x86 // 生成so文件的平台 ，设置为all, 代表所有平台\n```\n切换到main目录下 执行ndk-build 生成so文件\n\n将我们生成的so文件复制到 app下的libs文件夹下，并配置build.gradle 文件\n\n在MainActivity中调用\n\n别问我图在哪儿，上传不了。","tags":["Android Reverse"],"categories":["study"]},{"title":"AUCTF一道逆向题","url":"/2020/04/06/AUCTF2020一道题/","content":"\n跟学弟一起做的一道逆向题，先给出了一个32位PE，破解之后发现flag不在那儿，至于破解过程我就不赘述了，感觉应该是个位移解密。\n![](https://i.imgur.com/fZUiBPu.png)\n这个时候我们发现他给出了一个新的IP，我们在网页上查看这个地址，发现网站里面有一个php文件，这就说明我们需要跟他的服务器进行交互。我尝试了一下发现怎么都不能交互成功，靠我仅有的web知识挣扎了一下，就放弃了。\n\n看完wp之后发现，给的PE文件里面竟然还有一个PE文件，用binwalk查看了一下发现0x24B0这里往后是一个新的PE，用winhex把它分离出来，得到新的PE文件，运行之后发现需要输入IP:PORT，正好之前给了新的地址和端口号，成功进入。\n![](https://i.imgur.com/KpOJo0u.png)\n当然这肯定没解决完，他肯定不会连上了就告诉你flag，所以后面我们分析这个PE文件，很显然都是GO语言，这里就要去学习GO语言了，第二种方法运行exe的时候用Wireshark抓包，web方向的知识我也不赘述了。\n贴上question.php代码\n```php\n\n<?php\n$my_headers = apache_request_headers();\n$hello = $_SERVER['HTTP_HELLO'];\n$hand = $_SERVER['HTTP_COOKIE'];\n\nif ($hello ==  \"hello can you hear me?\"){\n\theader(\"COOKIE:you_found_me\");\n\techo \"Ahh. I see you've found me... here comes the flag :)\\n\";\n}\nif ($hand == \"you_found_me\"){\n\t\techo \"auctf{r3s0urc3_h4cK1Ng_1S_n3at0_1021}\\n\";\n\t}\n?>\n\n```\n之所以写这个是因为最近看了嘶吼公众号推的一篇文章，APT组织利用IE和Firefox漏洞攻击，感觉在这个攻击手段跟这题解决方法在某些方面有点类似，只不过这个要简单很多。","tags":["Android Reverse"],"categories":["study"]},{"title":"流加密rc4","url":"/2019/11/05/流加密rc4/","content":"在密码学中，RC4（来自Rivest Cipher 4的缩写）是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。该算法是一个可变密钥长度、面向字节操作的流密码。该算法以随机置换作为基础，其密码周期很可能大于10100，且该算法的运行速度很快。（来自百度百科）\n\nRC4密钥生成步骤主要分成两部分初始化算法（KSA）和伪随机子密码生成算法（PRGA)两大部分。先放上图助于理解：\n![](https://i.imgur.com/mtt6esP.jpg)\n# 初始化算法： #\n\n## 初始化状态向量S（256个字节，用来作为密钥流生成的种子1）： ##\n给向量S256字节一一赋值，从0，1，2，3......255。\n```c\nint s[256] = {0};\nfor(int i = 0; i < 256; i++)\n{\n\ts[i] = i;\n}\n```\n\n## 初始密钥（256字节，不满循环填满）： ##\n这个值是用户自定义的，长度任意，不满256字节循环填满，非明文，是已知的\n```\nchar *key = \"aaaaaa\";\nint len = strlen(key);\nunsigned char k[256] = {0};\nfor(int i = 0;i < 256; i++)\n{\n\tk[i] = key[i/len];\n}\n```\n\n## 对状态向量S进行置换操作（打乱S_box）： ##\n规则如下：\n```c\nint j = 0;\nchar temp;\nfor(int i = 0;i < 256; i++)\n{\n\tj = (j + s[i] + k[i])%256;\n\ttemp = s[i];\n\ts[i] = s[j];\n\ts[j] = temp;\n}\n```\n# 伪随机子密码生成算法 #\n加密：明文字节数为：datalength\n```c\nint i = 0;\nint j = 0;\nwhile(datalength--)\n{\n\ti = (i + 1)%256;\n\tj = (j + s[i])%256;\n\tswap(s[i] , s[j]);\n\tt = (s[i] + s[j])%256;\n\tdata[i] = data[i] ^ s[t];\n}\n```\n解密：明文异或一次得到密文，再异或一次得到原来的明文\n\n参考百度百科完整代码：\n```c\n//程序开始\n#include<stdio.h>\n#include<string.h>\ntypedef unsigned longULONG;\n \n/*初始化函数*/\nvoid rc4_init(unsigned char*s, unsigned char*key, unsigned long Len)\n{\n    int i = 0, j = 0;\n    char k[256] = { 0 };\n    unsigned char tmp = 0;\n    for (i = 0; i<256; i++)\n    {\n        s[i] = i;\n        k[i] = key[i%Len];\n    }\n    for (i = 0; i<256; i++)\n    {\n        j = (j + s[i] + k[i]) % 256;\n        tmp = s[i];\n        s[i] = s[j];//交换s[i]和s[j]\n        s[j] = tmp;\n    }\n}\n \n/*加解密*/\nvoid rc4_crypt(unsigned char*s, unsigned char*Data, unsigned long Len)\n{\n    int i = 0, j = 0, t = 0;\n    unsigned long k = 0;\n    unsigned char tmp;\n    for (k = 0; k<Len; k++)\n    {\n        i = (i + 1) % 256;\n        j = (j + s[i]) % 256;\n        tmp = s[i];\n        s[i] = s[j];//交换s[x]和s[y]\n        s[j] = tmp;\n        t = (s[i] + s[j]) % 256;\n        Data[k] ^= s[t];\n    }\n}\n \nint main()\n{\n    unsigned char s[256] = { 0 }, s2[256] = { 0 };//S-box\n    char key[256] = { \"justfortest\" };\n    char pData[512] = {0};\n    unsigned long len = 0;\n    int i;\n\n\tscanf(\"%s\",&pData); \n\tlen = strlen(pData); \n    printf(\"pData=%s\\n\", pData);\n    printf(\"key=%s,length=%d\\n\\n\", key, strlen(key));\n    rc4_init(s, (unsigned char*)key, strlen(key));//已经完成了初始化\n    printf(\"完成对S[i]的初始化，如下：\\n\\n\");\n    for (i = 0; i<256; i++)\n    {\n        printf(\"%02X\", s[i]);\n        if (i && (i + 1) % 16 == 0)putchar('\\n');\n    }\n    printf(\"\\n\\n\");\n    for (i = 0; i<256; i++)//用s2[i]暂时保留经过初始化的s[i]，很重要的！！！\n    {\n        s2[i] = s[i];\n    }\n    printf(\"已经初始化，现在加密:\\n\\n\");\n    rc4_crypt(s, (unsigned char*)pData, len);//加密\n    printf(\"pData=%s\\n\\n\", pData);\n    printf(\"已经加密，现在解密:\\n\\n\");\n    //rc4_init(s,(unsignedchar*)key,strlen(key));//初始化密钥\n    rc4_crypt(s2, (unsigned char*)pData, len);//解密\n    printf(\"pData=%s\\n\\n\", pData);\n    return 0;\n}\n \n//程序完\n```\n参考文章：[https://www.cnblogs.com/gambler/p/9075415.html](https://www.cnblogs.com/gambler/p/9075415.html)","tags":["cryptography"],"categories":["study"]},{"title":"Android 逆向学习中遇到的问题","url":"/2019/09/06/Android开发中遇到的问题/","content":"# Android studio安装过程中的问题 #\n首先是安装中遇到的问题，参考超详细博客[https://blog.csdn.net/hebbely/article/details/78970918](https://blog.csdn.net/hebbely/article/details/78970918)\n\n# 关于万能布局 #\n关于万能布局ConstraintLayout在3.0以上的版本处理办法，参考博客：[https://blog.csdn.net/BSSYNHDJZMH/article/details/79728625](https://blog.csdn.net/BSSYNHDJZMH/article/details/79728625)\n显然Android studio自带的约束控件并不能满足ui各种各样的保真所以上述大佬写了详细ConstraintLayout完全解析\n\n# smali文件动态调试出现的问题 #\n关于动态调试smali文件出现的一些问题\n\n首先把smali文件夹导出后一定要放在一个文件夹里面并且将smali文件改名为src\n\n检查xml文件是不是有允许调试的语句\n\n关于android device monitor在Android SDK安装文件夹tools文件夹下monitor.bat双击即可打开\n\n输入命令adb shell -D -n hfdcxy.com.myapplication/hfdcxy.com.myapplication.MainActivity只能使用这个命令，其他命令搜索不到\n\nandroid device monitor 查看online端口，查看完就关闭，否则后面会转发端口失败\n\n打开命令行窗口 输入命令 adb forward tcp:8700 jdwp:19509    转发8700 端口 (这里 jdwp是自己Android Device Monitor中要调试app的Online值 )\n\n后面重新打开Android studio调试文件不能下断点，后来发现重新调试文件的时候没有安装ideasmali，要重新在安装上才能下断点\n\n# 关于使用Android studio出现的一些问题 #\n在某一天我打开Android studio我发现他坏了。。。\n1.AndroidStudio中Could not find any version that matches com.android.support:appcompat-v7:29.+.\n解决方案：改为 --> implementation 'com.android.support:appcompat-v7:+' 即可\n参考https://blog.csdn.net/hai1124948893/article/details/85247737\n2.修改gradle路径，参考网上教程","tags":["Android Reverse"],"categories":["study"]},{"title":"Android 逆向学习","url":"/2019/09/04/Android逆向/","content":"# smali基础 #\nsmali语法学习，参考吾爱破解安卓逆向入门学习[https://www.52pojie.cn/thread-408645-1-1.html](https://www.52pojie.cn/thread-408645-1-1.html)\n![](https://i.imgur.com/vSN2ZAy.jpg)\n![](https://i.imgur.com/6I1GHER.jpg)\n![](https://i.imgur.com/tBwzBWO.jpg)\n![](https://i.imgur.com/eDRiUON.jpg)\n![](https://i.imgur.com/oEOhZDa.jpg)\n\n## 记录一些易混淆的点 ##\n### 寄存器p0 ###\n在**非**static方法中，**p0**代指**this**，**p1**为方法的第一个**参数**。\n在static方法中，**p0**为方法的第一个**参数**。\n\n### .local与.locals ###\n```smali\n\t.local v1, \"future\":Lcom/android/volley/toolbox/RequestFuture;, \"Lcom/android/volley/toolbox/RequestFuture<Ljava/lang/Void;>;\"\n```\n这里的.local表示的是\n```\n\tRequestFuture<Void> future； \n\tfuture = v1；\n```\n.locals 数字 定义所学内部变量数，即v寄存器的数\n\n# smali的函数调用 #\nsmali中的函数和成员变量分为direct和virtual，direct method就是private函数，其余的public和protect函数是virtual method。\n\ninvoke-XXX指令：\n1. invok-static：调用static函数\n2. invoke-super：调用父类方法指令，一般用于调用onCreate，onDestroy等方法。\n3. invoke-direct：调用privat函数\n4. invoke-virtual：调用public和protect函数\n# 破解的程序和游戏 #\n安装adb过程参考博客[https://www.cnblogs.com/nebie/p/9145627.html](https://www.cnblogs.com/nebie/p/9145627.html)\n破解过的游戏：\n# 动态调试 #\n具体会在另一个博客详细讲解，详细学习Java层和so层动态调试后写的博客\n\n","tags":["Android Reverse"],"categories":["study"]},{"title":"国密sm4","url":"/2019/08/28/国密sm4/","content":"\n最近国密SM4加密挺火的，毕竟是中国国家密码局认定的国产密码算法，在逆向加密中出现的比较多。\n\n## SM4原理 ##\n\n国密SM4[官方文档](http://dacas.cn/sharedimages/ARTICLES/SMAlgorithms/SM4.pdf),个人认为官方文档挺好理解的。还有就是一个人截图的浙大diffie教授的[课件图片](https://blog.csdn.net/zhangpeterx/article/details/83654504)个人觉得里面的图片也很好理解，毕竟国内的资料里面基本没有很好理解的图（悄咪咪搜了一下diffie教授瞬间羡慕好学校的学生们）\n\n## 加密 ##\n\n**SM4加密分为三个过程：轮密钥的准备，32次迭代运算，后四位反序得结果**\n\n### 32次迭代运算 ###\n\n![](https://i.imgur.com/FPx1NtS.png)\n\n图上是32次迭代运算的公式，其中x为输入的值(32bit)，F()是轮函数，rk[i]是轮密钥(32bit)。**轮函数**的表达式是：\n\n![](https://i.imgur.com/plsjIQr.png)\n\n即X1与x2与x3与轮密钥rk[i]异或后的值经过**合成置换T函数**再与x0异或。\n合成置换T，由**非线性变换τ**和**先行变换L**复合而成：\n![](https://i.imgur.com/9cssMkC.png)\n\n1.非线性变换τ\n\n非线性变化τ主要操作是把输入的A(8bit)分成四份分别对应到s盒(已知矩阵)中\n\n![](https://i.imgur.com/sX7qAge.png)\n\n2.线性变换L\n\n非线性变换的输出即为线性变换的输入，过程为：\n![](https://i.imgur.com/mKuplwC.png)\n\n### 反序变换 ###\n\n看到这里是不是已经忘记32次迭代运算是什么了.....我们来回顾一下32次迭代运算，以上经过合成置换得到的值要与输入的第一个值x0异或得到的值即为x4的值，经过上面32次轮函数的循环，就能得到新的x0(32bit)到x32的值，最后将最后四个值经过**反序变换**：\n\n![](https://i.imgur.com/1drebMg.png)\n\n输出即为加密过后的值\n\n### 轮密钥的准备 ###\n\n轮密钥的准备放在后面讲是因为轮密钥也使用了合成置换，但是这个合成置换与前面的轮函数中的合成置换有一点区别。\n轮密钥生成方法：\n\n![](https://i.imgur.com/mCSY2SF.png)\n\n输入加密密钥MK(128bit)分成四份MK0(32bit),MK1,MK2.MK3分别与系统参数(已知)FK0,FK1,FK2,FK3异或，下面一个公式我们可以得到两个重要步骤。其中CK[i]为固定参数。\n\n第一步：是类似于32迭代运算的公式得到k[i+4]((32bit)\n\n第二步：是我们得到的这个k[i+4]赋值给了rk[i]((32bit)\n\n T′ 是将32次迭代运算中合成置换T的线性变换L替换为L′：\n![](https://i.imgur.com/dwpNmtI.png)\n系统参数FK的取值：\n![](https://i.imgur.com/V855HA8.png)\n固定参数CK具体值为：![](https://i.imgur.com/oGtEKvt.png)\n\n## 解密 ##\n本算法的解密变换与加密变换结构相同，不同的仅是轮密钥的使用顺序。解密时，使用轮密钥顺序为（rk31,rk30,...,rk0）.\n\n## 实现脚本 ##\n正在修缮中...","tags":["cryptography"],"categories":["study"]},{"title":"中关村第三届新兴领域专题赛网络与信息安全专项赛线上赛re","url":"/2019/08/23/专项赛/","content":"贴上题目：[https://pan.baidu.com/s/1CPj02KTrmNfNP6JCFRk26Q](https://pan.baidu.com/s/1CPj02KTrmNfNP6JCFRk26Q)提取码：el57\n## flat ##\n\n程序逻辑\n\n1.  check1():判断输入字符串长度是否在50以内\n\n2.  check2():判断输入字符串前几位是否为“flag{”\n\n3.  check3():最后一位是否为“}”\n\n4.  check4():14,19,23,28 是否为“-”\n\n5.  check5():字符串进行字符替换比较\n\n这里是llvm，[https://security.tencent.com/index.php/blog/msg/112](https://security.tencent.com/index.php/blog/msg/112 \"学习链接\")\n\n脚本：\n```python\na = 'J2261C63-3I2I-EGE4-IBCC-IE41A5I5F4HB'\nans = ''\n\nfor i in range(0,len(a)):\n        if(ord(a[i])>=65):\n                ans+=chr(ord(a[i])-17)\n        if(a[i]=='-'):\n                ans+=a[i]\n        if(ord(a[i])>=48):\n                if(ord(a[i])<=57):\n                        ans+=chr(ord(a[i])+48)\n\nprint ans\n```\n\n## src_leak ##\n\nfunc3<func2<x>>这个函数的意思是测试x变为2进制中x含有多少个1，且含1的个数是奇数个\n\n_fun1<x>的意思是开根号，可以根据func1<>处函数可以看出得到result的条件是L=R，而在ifelse<>函数里面当n<mid*mid时L不变，R减小；当n>=mid*mid时R不变，L变大。并且保证这几个数和是可能中的最小值，所以反推output平方即是。\n\n最后x6是1到10000有多少素数\nflag{927369-19324816-44435556-3996001-9865881-1229}","tags":["CTF"],"categories":["competition"]},{"title":"base64一些特征","url":"/2019/05/13/关于base64在逆向里面的一些特征/","content":"base64加密是逆向中常见的加密手段，但是如何发现是base64加密呢？\n\n编码原理\n\nbase64加密之后所有的字符都应该在这个表中\n![](https://i.imgur.com/EGaILLP.png)\nbase64编码是将x个8位字节变成y个6位字节然后再以00填充变成n个新的八位字节，再将二进制转换成十进制，一一替换字符。\n举个栗子：\n假设待转化的字符是 “example”\n\n转化成二进制之后得到\n\n01100101 01111000 01100001 01101101 01110000 01101100 01100101\n\nexample的长度是7因此为了使得最后得到的字符是4的倍数我们要再添上两个字符\n\n01100101 01111000 01100001 01101101 01110000 01101100 01100101 00000000 00000000\n\n然后我们将其按照6位1字符排好\n\n011001 010111 100001 100001 011011 010111 000001 101100 011001 010000 000000 000000\n\n填充00之后得到\n\n00011001 00010111 00100001 00100001 00011011 00010111 00000001 00101100 00011001 00010000 00000000 00000000\n\n再将这些二进制转换成十进制\n\n25 23 33 33 27 23 1 44 25 16 0 0\n\n对照表用字符替换之后得到\n\nZXhhbXBsZQAA\n\n再将最后的AA换成==即可\n\nZXhhbXBsZQ==\n\n","tags":["Reverse"],"categories":["study"]},{"title":"锁定文件失败 打不开磁盘“D:\\ubuntu\\Ubuntu 64 位.vmdk”或它所依赖的某个快照磁盘。 模块“Disk”启动失败。","url":"/2019/04/10/关于虚拟机锁定文件错误/","content":"\n锁定文件失败 打不开磁盘“D:\\ubuntu\\Ubuntu 64 位.vmdk”或它所依赖的某个快照磁盘。 模块“Disk”启动失败。\n\nUbuntu虚拟机非正常关闭，再次打开有时候会出现“锁定文件失败，打不开磁盘……”的错误提示\n解决办法：打开虚拟机所在路径\n删除.vmdk.lck及.vmx.lck两个文件夹中的.lck文件\n\n![](https://img-blog.csdn.net/20180918224324732?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E2ODY0NjU3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n重启就能使用了","tags":["program"],"categories":["problem"]},{"title":"2019 UTCTF","url":"/2019/04/01/UTCTF/","content":"## Low Sodium Bagel ##\n```python\n\t$ steghide extract -sf low-sodium-bagel.jpeg -p \"\"\n\twrote extracted data to \"steganopayload4837.txt\".\n\t$ cat steganopayload4837.txt\n\tutflag{b1u3b3rry_b4g3ls_4r3_th3_b3st}\n```\n关于steghide一些使用简单的爆破脚本[https://blog.csdn.net/blood_seeker/article/details/81837571](https://blog.csdn.net/blood_seeker/article/details/81837571)关于一些steghide参数介绍[https://blog.csdn.net/qq_40657585/article/details/83931078](https://blog.csdn.net/qq_40657585/article/details/83931078)\n\n## UTCTF adventure ROM ##\n这一题要感谢[dotsu师傅](https://xz.aliyun.com/t/4393)的指导，让我这个小白学到了一点东西。\n\n首先是如何打开.gb文件，使用的是Gameboy反汇编追踪工具BGB，BGB 是一款运行于windows 的GameBoy，GameBoy Color 和 Super GameBoy 。模拟器打开的界面如下：\n![](_v_images/20190401211432664_29874.png)\n开始随便转了转，就DEAD了，然后看了大佬的解释说能输入ABCD，开始找了半天输入，后来才知道要站在每个方框内按A就可以输入了，这样我们可以猜测游戏逻辑，碰到隐藏的东西会死掉，输入不对会LOSER\n\n用IDA分析文件中选择z80处理器，加载进去后还是binary文件，纠结了好久去问了dotsu师傅，最后给出了解决办法：IDA里edit->select all，然后按C键选force，这样会强制解析整个文件，但是里面的数据和字符串也会被解析为指令，可以对照着hex窗口，按A转为字符串或者按D转为数据。果然大佬就是大佬啊经验丰富，先找到放关键字的地方转字符串![](_v_images/20190401214458317_487.png)\n\n然后找到引用字符串的函数，按x不管用，search->text也不行，只能手动找了，这里是我看到放关键字符串的地方下面就是sub_73b函数所以猜测引用在sub_33E这个函数里面，看流程图就找到了引用的函数，这样我们就能知道出现DEAD的逻辑了，然后nop掉（nop方法\\x00），这样游戏的限制就没有了，同样的方法把所有的DEAD都nop掉，然后选择patch中应用到该文件中\n![](_v_images/20190401215303556_20232.png)\n\n再找到引用LOSER的函数，向上就能看到比较寄存器a，c的值，如果相等就继续循环，如果不相等就跳到LOAER处，那我们只要能弄清楚a和c谁存的是输入的，谁存的是正确值，就能拿到flag了。后面就是用gbg中的debugger来反汇编比较寄存器a，c的值，在比较处下断点，随便输入（F2下断点，F3单步执行，F9继续执行），gbg比较方便能修改寄存器的值修改指令知道结束，并把每一次寄存器c里面的值记录下来，连在一起就是flag。\n\n## mov ##\nIDA加载发现全是MOV指令，可以大概知道使用了[Movfuscator](https://github.com/xoreaxeaxeax/movfuscator)进行了混淆处理。\n\n对于复杂一些的Movfuscator程序，可以尝试根据程序中字符串等信息，配合trace工具和下断点来追踪程序流程，并猜测程序逻辑（一般来说逻辑不会特别复杂）。此外，也可以尝试使用Demovfuscator进行反混淆，运气好的话说不定会解得比较好看。（这些都是dutsu师傅写的，小白正学习中）\n\n在gdb中调试，遇到sigill信号会停住，然后发现栈中有一个字符\"u\"，再试一下就会发现utflag，继续就能得到flag。\n\n### 关于Movfuscator的学习 ###\n\n根据官方介绍Movfuscator是一个单指令C编译器（the single instruction C compiler）","tags":["CTF"],"categories":["competition"]},{"title":"2019看雪论坛ctf","url":"/2019/03/12/看雪2019/","content":"\n## 流浪者 ##\n提取码s7pn\n链接[https://pan.baidu.com/s/1xFLUjOETe9ICFdJqVTcYlw](https://pan.baidu.com/s/1xFLUjOETe9ICFdJqVTcYlw )\n\n首先题目入口函数是sub_401890，我是通过在OD里面查找字符串，找到“请输入pass”的地址，然后在IDA中找到该函数并反汇编得到了整个函数![](https://i.imgur.com/XpwZDIh.jpg)\n\n进入sub_4017F0函数通过条件得到pass\n![](https://i.imgur.com/CX9A2Qe.png)\n\n脚本如下：\n```python\n\tkey = 'KanXueCTF2019JustForhappy'\n\tstr1 = 'abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ'\n\ta1 = ''\n\tfor i in range(0,len(key)):\n\t\tfor j in range(0,62):\n\t\t\tif(str1[j] == key[i]):\n\t\t\t\tif(j >= 0):\n\t\t\t\t\tif(j <= 9):\n\t\t\t\t\t\ta1 += chr(j + 48)\n\t\t\t\tif(j >= 10):\n\t\t\t\t\tif(j <= 35):\n\t\t\t\t\t\ta1 += chr(j + 87)\n\t\t\t\tif(j >= 36):\n\t\t\t\t\tif(j <= 61):\n\t\t\t\t\t\ta1 += chr(j + 29)\t\t\n\tprint(a1)\n```\nflag是```j0rXI4bTeustBiIGHeCF70DDM```","tags":["CTF"],"categories":["competition"]},{"title":"TAMU CTF Re","url":"/2019/03/05/TAMU CTF Re/","content":"TAMU CTF 逆向有简单也有复杂的，前天刚结束，今天把这个总结一下。\n附上题目，提取码rb8r[https://pan.baidu.com/s/1A5G-pRd3oYkzVYVJDVIxvQ](https://pan.baidu.com/s/1A5G-pRd3oYkzVYVJDVIxvQ)\n\n# Cheesy #\n\n文件放到Ubuntu中运行一遍，发现采用了base64编码，把给出的加密代码解密，并没有发现flag，并且解密之后告诉你你已经错过了flag，所以考虑，是否还有未解密的隐藏代码，放到ida中发现了\n```\nZ2lnZW17M2E1eV9SM3YzcjUxTjYhfQ==\n```\n这一串密码未输出，经过解密就是flag\n```\ngigem{3a5y_R3v3r51N6!}\n```\n# Snakes over cheese #\n\n给的是一个.pyc文件，用uncompyle反编译一下得到.py文件，使用命令\n```\nuncompyle6 reversing2.pyc > reversing2.py\n```\n的得到如下的py文件，运行一下发现需要输入正确的密码才能给你flag\n不用那么麻烦的把密码给逆向出来，直接修改一下py文件直接得出flag![](https://i.imgur.com/lTqDFRF.png)\n运行结果如下：\n\n![](https://i.imgur.com/VYM1dQk.png)\n\n# 042 #\n\n这是一道真正的反汇编，给的文件不能编译所以要纯看汇编代码，但是这个汇编代码还是很简单的，前面第一个function是一个迷惑代码，实质上没用，主要看main函数，关键代码在如下地方![](https://i.imgur.com/jvvwX2N.png)\n在第二printf函数后面放入的是栈中[rbp-16]的地址，即从[rbp-16]向下取值回到上面就能看到存入栈中的值，即可获得flag\n```\ngigem{A553Mb1Y}\n```\n# keygenme #\n把enc()这个函数逆向就完了，但是有一个需要注意的地方，这里输入的a1在运行过程中strlen()函数包含了输入时的回车符'\\n'所以根据得到v5知道a1的长度应该是17，但是包含了最后的回车符，所以a1只有16个，脚本如下![](https://i.imgur.com/ffqFf4X.png)\n提交就能得到flag，比赛的时候一直没有想到这个问题，知道是多了个'Enter'但是实在没想到是这样，比赛结束后用C语言正着证明了一遍\n![](https://i.imgur.com/ckwb2Z8.png)\n![](https://i.imgur.com/Al0tO39.png)\n\n#NoCCBytes#\n放到ida里面re了一下发现答案在globPass中，显然DATA中的字符串肯定不是，但是我们可以动态调试啊，但是文件开了保护机制，所以下断点的时候要绕开这些保护机制，所以直接一点直接把断点下在字符串比较的地方。然后就看到内存中的golbpass\n![](https://i.imgur.com/XWUxGlE.png)\n满眼答案...提交就能得到flag\n","tags":["CTF"],"categories":["competition"]},{"title":"2019 Seasides CTF breakthis","url":"/2019/03/01/Seasides CTF 2019 re/","content":"这个比赛当时比的时候没找到时间，比的时候只剩最后两个小时，所以只做了两道re，nondbg这题应该比较明显按照代码的顺序把字符串正确输入就会得到flag，breakthis也很简单，验证你输入的flag是否正确，你输入的flag经过base64，rot13，uuencode加密后要跟flag_encode一样，而flag_encode已知，只要将他反过来解密就行，写这篇的意义主要是学习使用python解密\n\n附上题目，提取码fdt4[https://pan.baidu.com/s/1tyLuV8hRLemkSlsq2Wk-QQ](https://pan.baidu.com/s/1tyLuV8hRLemkSlsq2Wk-QQ)\n\n编码转换时，通常要以Unicode为中间编码，即都需要将字符串先解码（decode）成Unicode再从Unicode编码成（encode）成另一种编码\n\n如果一个字符串已经是unicode了，再进行解码则将出错,因此通常要对其编码方式是否为unicode进行判断isinstance(s, unicode) #用来判断是否为unicode \n\nuuencode是将二进制文件编码成为ascii，uudecode是用于uuencode编码的文件还原为原来的二进制文件。关于uuencode输出数据，都是以begin开头，以end结尾。begin后面644是unix档案调用的权限代码\n\n关于codecs的使用手册介绍[https://docs.python.org/3/library/codecs.html](https://docs.python.org/3/library/codecs.html)\n\n下面是解密代码，需要注意uuencode的格式\n\n![](https://i.imgur.com/4hrG4Hj.png)\n\n取得flag\n\n![](https://i.imgur.com/osrLI6O.png)\n\n附上一些可以直接用python编码和解码的一些密码，这样能大大的节约时间，但是注意python2.7和python3的区别，byte string和Unicode string编码要求在python3中的要求就更严格，在python3中区分了二进制和字符串，所以这个脚本在python3中会出现问题![](https://i.imgur.com/b6Zumt6.png)","tags":["CTF"],"categories":["competition"]},{"title":"我的二进制学习道路","url":"/2018/11/27/我的二进制学习道路/","content":"## Bin\n**前置技能**：\n\n  - 掌握汇编基础：Python、王爽《汇编语言》、虚拟机安装Ubuntu（建议版本16.4）、Linux基本操作、GDB调试、IDA调试（静态调试）（前期懂简单操作就行，后面根据视频以及使用手册再增加）\n  - 工具说明书：[GDB使用手册](https://blog.csdn.net/weiyuefei/article/details/72522973),[IDA PRO使用技巧](https://xz.aliyun.com/t/4205) ，找到比较好的可以交流一波\n\n### Pwn\n  - 基础的调试、入门首选 [LiveOverFlow](http://liveoverflow.com/binary_hacking/) （翻墙官网能自动翻译）\n  - 学习 stack overflow：明白原理，完成例题 [基本ROP](https://ctf-wiki.github.io/ctf-wiki/pwn/stackoverflow/basic_rop/)\n  - 继续完成 ctf-wiki 栈溢出部分\n\n  前面都完成的开始进阶\n  - [how2heap](https://github.com/shellphish/how2heap)\n  - [pwnable.tw](https://pwnable.tw/)、[pwnable.kr](http://pwnable.kr/play.php)\n  - CTFTime ...\n\n### Reverse\n  - 在前置技能完成后推荐找一个讲解ctf逆向题目的入门视频，一是了解ida基本的静态调试，二是增加兴趣\n  - 增加工具：虚拟机安装win7、吾爱破解Ollydug（动态调试）\n  - 推荐入门视频：[吾爱破解逆向入门套餐](https://www.52pojie.cn/thread-582852-1-1.html)(适量使用)\n  - 学习程序调试技能：逆向工程核心原理、加密解密、0day安全\n  - 可选学习教程 [reversingwithlena-tutroial](https://tuts4you.com/e107_plugins/download/download.php?action=view&id=2876) 一篇 简单的 crackme [An Intro to x86_64 Reverse Engineering](https://leotindall.com/tutorial/an-intro-to-x86_64-reverse-engineering/)\n\n  之后就是不停的练习 [crackmes](https://github.com/crackmes/crackmes) 以及内功修炼：程序开发、操作系统、编译原理 ...\n\n### 参考资料\n  - [Linux (x86) Exploit Development Series](https://sploitfun.wordpress.com/2015/06/26/linux-x86-exploit-development-tutorial-series/)\n  - [Linux (x86) Exploit 开发系列教程](https://bbs.pediy.com/thread-217390.htm)\n  - windows平台： [Exploit writing tutorial part 1 : Stack Based Overflows](https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/)、[Part 1: Introduction to Exploit Development](https://www.fuzzysecurity.com/tutorials/expDev/1.html)\n  - [exploit入门级](http://martin.uy/blog/projects/reverse-engineering/)\n  - [一步一步学ROP x86](http://www.vuln.cn/6645)\n  - 论坛：看雪、吾爱、tuts4you**（逛论坛很重要，大佬，学习资料，工具，题解，不懂的问题都能找到）**\n# Reference\n- [Web-Security-Learning](https://github.com/CHYbeta/Web-Security-Learning) （较好的web安全相关学习资源）\n- [CTF-All-In-One](https://github.com/firmianay/CTF-All-In-One) （一本 CTF 领域的大杂烩指南）\n- [Awesome-Hacking](https://github.com/Hack-with-Github/Awesome-Hacking) （非常全面的黑客技术清单）\n- [CTF-Wiki](https://ctf-wiki.github.io/ctf-wiki/) （CTF的入门简介）","tags":["Reverse"],"categories":["study"]},{"title":"关于逆向学习的一些知识","url":"/2018/11/23/逆向学习/","content":"\nAPI：API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。\nAPI函数包含在Windows系统目录下的**动态连接库**文件中。。API说来说去，就是一种函数，他们包含在一个附加名为DLL的动态连接库文件中。Windows API是一套用来控制Windows的各个部件的外观和行为的预先定义的Windows函数。用户的每个动作都会引发一个或几个函数的运行以告诉Windows发生了什么。这在某种程度上很像Windows的天然代码。而其他的语言只是提供一种能自动而且更容易的访问API的方法。当你点击窗体上的一个按钮时，Windows会发送一个消息给窗体，VB获取这个调用并经过分析后生成一个特定事件。\n更易理解来说：Windows系统除了协调应用程序的执行、内存的分配、系统资源的管理外，同时他也是一个很大的服务中心。调用这个服务中心的各种服务(每一种服务就是一个函数)可以帮助应用程序达到开启视窗、描绘图形和使用周边设备等目的，由于这些函数服务的对象是应用程序，所以称之为Application Programming Interface，简称API 函数。WIN32 API也就是MicrosoftWindows 32位平台的应用程序编程接口。\n凡是在 Windows工作环境底下执行的应用程序，都可以调用Windows API。\n其实就是用户指令先由编程语言编程成电脑能读懂的语言，这个语言能自动的更快的访问API，这样应用程序通过API与Windows某些部件连接起来，让Windows内部运作起来完成用户指令，并返回给用户界面。API是应用程序接口。你可以在其他的程序中，通过一定的规范通过API发送信息给另一个程序，并接收返回的结果。看了很多，一个很有意思的回答是，双方交流的暗号\n\nvc6入口代码特征：都是push ebp；mov ebp，esp类似的；入口调用API也是相同的\nvc6的四个区段：.text代码段.rdata导入表（只读数据段）.data数据段.rsrc资源段\nvs2008和vs2013相较于vc6：入口代码只有两行，vs2018是一个call后面接一个jmp，第一个call里面进去后也是push ebp啥啥的，调用的API也相同\nVB启动代码：jmp ThunRTMain();push RT_MainStruct结构体函数地址；call (jum ThunRTMain()地址);前面压入栈的的值作为ThunRTMain()函数参数\n\n易语言（非独立编译）：编译时很明显的运行库文件，入口特征和模块特征都有krnln.fnr，易语言支持库有.fnr格式,.fne格式和.npk格式\n\nOD被压缩后分析：ctrl+A\n加aspack壳的特征：入口特征pushad，一个call和jmp，并且会增加两个区段\n\n加UPX壳后特征：\n\nhttps://www.cnblogs.com/Fightingbirds/p/3172907.html ","tags":["Reverse"],"categories":["study"]},{"title":"2018i春秋骇极杯what","url":"/2018/11/07/2018i春秋骇极杯what/","content":"骇极杯第二个逆向，也不难，也是两个函数，首先是爆破MD5，然后进行动态解密check函数\n\n这是结束几天之后，我再来写的wp，我开始觉得很简单的，后来看了详细的过程之后我觉得我还是有很多却缺陷的，下面开始一步一步分析\n\n首先拖进ida，主要分两部分来看：\n![](https://i.imgur.com/SgicMs0.png)\n\n要先得到luck string才能获得check函数的内容，所以先对MD5进行爆破\n\n\t```python\n\timport hashlib\n\tfor a1 in range(97,123):\n\t\tfor a2 in range(97,123):\n\t\t\tfor a3 in range(97,123):\n\t\t\t\tfor a4 in range(97,123):\n\t\t\t\t\tfor a5 in range(97,123):\n\t\t\t\t\t\tfor a6 in range(97,123):\n\t\t\t\t\t\t\tasc=hashlib.md5((char(a1)+char(a2)+char(a3)+char(a4)+char(a5)+char(a6)).encode('ascii')).hexdigest()\n\t\t\t\t\t\t\tv5=0\n\t\t\t\t\t\t\tv4=0\n\t\t\t\t\t\t\tfor i in range(32):\n\t\t\t\t\t\t\tif(asc[i]=='0'):\n\t\t\t\t\t\t\t\tv5+=1\n\t\t\t\t\t\t\t\tv4+=i\n\t\t\t\t\t\t\tif(10*v5+v4==403):\n\t\t\t\t\t\t\t\tprint(chr(a1)+chr(a2)+chr(a3)+chr(a4)+chr(a5)+chr(a6))\n\t```\n\n脚本我放在虚拟机里面跑了半个小时，最后得出了luck string = `ozulmt`。\n\n再弄出v4和v5\n\t\n\t","tags":["CTF"],"categories":["competition"]},{"title":"关于git bash无法上传更新博客","url":"/2018/11/06/关于git bash无法上传/","content":"  之前blog不知道出了什么问题一直显示上传成功，却依旧不能更新，后来才发现问题，如图：![](https://i.imgur.com/g7kV8OY.png)\n  \n  **配置缺少GitHub邮箱和用户名**.....好的吧，加上加上\n  ![](https://i.imgur.com/fw81xiO.png)\n\n  上传文件到远程仓库\n![](https://i.imgur.com/L7v7FHm.png)","tags":["problem"],"categories":["problem"]},{"title":"2018网鼎杯之beijing","url":"/2018/11/06/2018网鼎杯之beijing/","content":"题目不难，但是我不会写脚本，学习的大佬的先贴上地址，稍后来写[https://blog.csdn.net/re_psyche/article/details/81947537](https://blog.csdn.net/re_psyche/article/details/81947537)","tags":["CTF"],"categories":["competition"]},{"title":"2018i春秋骇极杯cpp","url":"/2018/11/04/i春秋骇极杯reverse/","content":"逆向呢真的是一边学一边写题过来的，我比较喜欢这样\n贴上题目[https://pan.baidu.com/s/1KDQs81aqUYl7T7E9mZO-SQ](https://pan.baidu.com/s/1KDQs81aqUYl7T7E9mZO-SQ)\n## C plus plus##\n拖到IDA里面看一看，发现main函数里面有两个特别重要的加密函数，点击进去看看![](https://i.imgur.com/xbpOf3D.png)\n因为正在学c++所以呢，就去把basic_ string这个类去看了一下（真的是萌新要学习的东西很多呢）\n\n贴上学习的地址，个人更偏向英文版，英文版：[http://www.cplusplus.com/reference/string/basic_string/basic_string/](http://www.cplusplus.com/reference/string/basic_string/basic_string/)\n中文版：[https://blog.csdn.net/hl156/article/details/80610597](https://blog.csdn.net/hl156/article/details/80610597)\n\n**basic_ string(char &s1,char &s2)**是把s2字符串赋值给s2；若是**basic_string(char &s1,int n)**是打印出s1前n个字符，以字符串的形式；**basic _string(char &s1,int n,int m**)若n<m是打印出s[n]到s[m]之间的字符串,若n>m是打印出s[n]后面m个字符（都包括s[n]）；**basic _string(int n,'a')**是打印n个a出来，等等....\n**~basic_string()**则是删除这个字符串\n**operate[](a1,i)**就是取字符串第i位的字符出来\n**c-str()**返回指向数组的指针，该数组包含表示basic _string对象当前值的以空字符结尾的字符序列（即C字符串）。即此数组包含构成basic _string对象的值的相同字符序列以及末尾的附加终止空字符（charT（））。下面代码助于理解，其中strtok这个函数下面是他的固定格\n\n![](https://i.imgur.com/Py02Hsg.png)\n好了，好了废话太多了\n\n以下是第一个加密函数![](https://i.imgur.com/NWKv9G1.png)\n经过调试无论如何都会通过第一加密函数的，第一个是简单的异或与位移所以算法就是左移数组六位|右移数组两位再按位异或\n\n第二个加密函数就比较复杂\n我调试了之后大概意思是跟前面一个异或\n\n下面是我的脚本，参考了大佬（[Mr.Riscker](https://mmmmmmlei.cn/2018/11/05/上海市大学生网络安全大赛/ \"Mr.Riscker\"))的代码的，觉得很简洁\n\n![](https://i.imgur.com/vWyHDsM.png)\n\n当当当，flag如下\n\n![](https://i.imgur.com/kG6im6q.png)\n\n偶然在吾爱论坛上找到了一个讲解及其细致的wp，很适合我这种新人看啊贴上地址[https://www.52pojie.cn/thread-819393-1-1.html](https://www.52pojie.cn/thread-819393-1-1.html)\n\n里面讲到了之前我没有注意到的几点，我重新加上：\n\n1. a<<2这个从哪里来：在ida上面第一个函数中有`v2 = 4 * *(char *)std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator[](a1, i);`这个并不是讲a1*4而是在进行\"a<<2\"的操作\n2. 代码中的&0xff：第一个加密函数进行了a[i]=(a[i]<<2|a[i]>>6)^i这样的一个操作，但是异或i这一步跑不出来，所以还要加上&0xff才行，byte类型的数字要&0xff再赋值给int类型，是想保持二进制补码的一致性（数据在计算机中存储是以二进制的方式，正数存储的二进制原码,负数存储的是二进制的补码，补码是负数的绝对值反码加1）","tags":["CTF"],"categories":["competition"]},{"title":"初学PWN---栈溢出","url":"/2018/10/12/初学pwn之栈溢出/","content":"经过百转千回弯弯绕绕我这个可爱的程序媛最终还是屈服在PWN的淫威下，接下来的内容是我PWN入门的一些知识，如果有什么知识性的错误，请大方指出来，给你奖励小发发❀\n\n首先，在学PWN之前我学了**C语言**和**汇编语言**，还了解一点**python**和**Linux系统**的基本操作，并且也有一点点**逆向工程** 的基础，学PWN主要是看**YouTube**上面一个声音巨好听的美国不露面小哥哥的视频，这个小哥哥三年前也是一边自学PWN一边录视频，讲的很基础好懂又幽默有趣，最近看到小哥哥去了拉斯维加斯参加**defcon** 和**blackhat**，而且那个小哥哥竟然还是个学生，无数次感觉输在了人生的起跑线上呢，我也才上大学，他在上大学就知道那么多知识，而我还只是个萌新呢，一起加油~~（暗戳戳的说一句，感觉那个小哥哥长得好高啊，对我来说高=帅）\n\n废话不多说，贴上视频地址[http://liveoverflow.com/](http://liveoverflow.com/ \"liveoverflow\")\n## stack0~4 ##\n这几个原理基本是差不多的，通过栈溢出将某值改变或者覆盖返回地址\n### 0~4的答案和需要注意的地方 ###\n**stack0**\n主要讲的是覆盖掉modified的值让它不等于0即可，那我们首先找到buff的地址和modified的地址\n`0x080483fd <main+9>: movl $0x0,0x5c(%esp)`为modified的地址\n\n(```)\n0x08048405 <main+17>:   lea    0x1c(%esp),%eax\n0x08048409 <main+21>:   mov    %eax,(%esp)\n(```)是buff的地址\n两个地址0x5c和0x1c相差0x40个字节再加上0X1个需要覆盖的字节\n\n*\t代码如下：\n\n\t\t$ python -c 'print \"A\"*0x40+\"\\x01\\x00\\x00\\x00\"' | ./stack\n\t\tyou have changed the 'modified' variable\n\n**stack1**\n让modified的地址等于0x61626364,思路同上题，不过要**注意**的是x86系列的电脑都是采用**小端序**的方式储存数据。\n\n*\t小端序和大端序：\n\n\t>小端序：字数据的低字节存储在低地址中。\n\t>大端序：字数据的高字节存储在低地址中。\n\n*\t代码如下：\n\n\t\t./stack1 $python -c 'print \"A\"*0x40+\"dcba\"'\n\t\tyou have correctly got the variable to the right value\n\n**stack2**\n此处需要设置环境变量GREENIE\n\n*\t代码如下：\n\n\t\t$ GREENIE=`python -c 'print \"A\"*0x40+\"\\x0a\\x0d\\x0a\\x0d\"'\n\t\t$ export GREENIE\n\t\t$ ./stack2\n\t\tyou have correctly modified the variable\n\n**stack3**\n此处我们需要跳到win函数处，首先获得win函数的地址:\n\n`(gdb)print win`得到`$1 = {void (void)} 0x8048424 <win>`\n获得地址之后直接覆盖fp\n\n*\t代码如下：\n\n\t\t$python -c 'print \"A\"*0x40+\"\\x24\\x84\\x04\\08\"' | ./stack3\n\t\tcalling function pointer, jumping to 0x08048424\n\t\tcode flow successfully changed\t\t\n\n**stack4**\n覆盖返回地址让他跳到win函数就行了，注意这里要多覆盖0x1字节，偏移为0x4c\n\n*\t代码如下：\n\n\t\t$ python -c 'print \"A\"*0x4C+\"\\xf4\\x83\\x04\\x08\"' | ./stack4\n\t\tcode flow successfully changed\n\t\tSegmentation fault\n## stack5 ##\n\n首先介绍shellcode：Shellcode实际是一段代码（也可以是填充数据），是用来发送到服务器利用特定漏洞的代码，一般可以获取权限。另外，Shellcode一般是作为数据发送给受攻击服务器的\n\n再介绍int 3（CC）：当被调试进程执行INT3指令导致一个异常时，调试器就会捕捉这个异常从而停在断点处，然后将断点处的指令恢复成原来的指令用INT3断点的好处是可以设置无数个断点，缺点是改变了原程序指令，容易被软件检测到。例如为了防范API被下断，一些软件会检测API的首地址是否为CCh，以此来判断是否被下了断点但是如果将断点下在函数的内部或者末尾，例如可以将断点下在函数入口的下一行，就可以躲过检测了\n\n再来说说整个做题的想法，代码极其简单，但是我思考了很久为什么要这么做，暂时无果，按照视频所讲通过在缓存区放入shellcode通过管道传输给stack5，然后得到root权限\n\nShellcode放在返回地址后面，前面跟上NOP Slot；这可以消除缓冲区位置的不确定性。 \n\n注意:非GDB运行和GDB运行，缓冲区的地址会有变化\n注意：这里使用的”()”会生成一个子shell；\n\n子shell中执行两条命令。\n\n第一条命令将payload输出到标准输出，通过管道传输给stack5；\n\n第二个命令cat从标准输入中读取数据输出到标准输出，也会通过管道传输给stack5；\n\n__ builtin_ return_ address(0)的含义是，得到当前函数返回地址，即此函数被别的函数调用，然后此函数执行完毕后，返回，所谓返回地址就是那时候的地址。_builtin_return_address(1)的含义是，得到当前函数的调用者的返回地址。注意是调用者的返回地址，而不是函数起始地址。利用__builtin_return_address来获得函数运行栈的方法。\n","tags":["PWN"],"categories":["study"]},{"title":"2018看雪论坛ctf第一题","url":"/2018/07/28/2018看雪论坛第一道题/","content":"\n  这是long long ago 以前的CTF简单的解题思路，刚开始接触的逆向工程，所以从简单的开始吧！（ps：下一篇应该是iscc逆向Reverse题解，这是我做出来的第一个逆向工程题）\n\n##2018看雪CTF之XCTF##\n\n  此处贴上题目：[https://pan.baidu.com/s/15AJ5rXllWDwMhsX2dUKHyQ](https://pan.baidu.com/s/15AJ5rXllWDwMhsX2dUKHyQ)\n\n  首先打开.exe文件可以看到如下：![](https://i.imgur.com/7caoScF.png)\n\n  要求输入正确的序列号......\n\n  正常情况下我们拖到OD里面看一下，找到关键句：\n  \n  ![](https://i.imgur.com/IGY118b.png)\n  \n   进入之后，随便输入一个值先调试一下：\n   \n  ![](https://i.imgur.com/p68Vpda.png)\n   \n   此时我们需要找到关键跳转，在关键跳转处下断点：\n  \n  ![](https://i.imgur.com/qjdbUyY.png)\n  \n   下完断点后，直接运行到断点处，发现寄存器这边多了一个ASCII码值，此值就是我们要找到的值：\n\n  ![](https://i.imgur.com/FjU4ID0.png)\n\n   这个时候我们把这个值输进去，明显不对，想到可能是16进制转字符串，得到答案：\n\n   ![](https://i.imgur.com/ZWR8EN5.png)\n\n\n   没错！！！答案就是如此简单，hhhh....","tags":["CTF"]}]